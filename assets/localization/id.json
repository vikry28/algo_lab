{
    "home_title": "Algo Lab Pro",
    "home_subtitle": "Kuasai Algoritma dengan Visualisasi Data Nyata",
    "learning_title": "Belajar Algoritma",
    "learning_subtitle": "Jelajahi dan praktikkan konsep algoritma.",
    "search_hint": "Cari algoritma atau kategori",
    "category_all": "Semua",
    "category_sorting": "Sorting",
    "category_graph": "Graf",
    "category_search": "Search",
    "category_cryptography": "Kriptografi",
    "category_tree": "Tree",
    "popular_modules": "Modul Populer",
    "sorting_algorithms": "Algoritma Pengurutan",
    "graph_algorithms": "Algoritma Graf",
    "search_algorithms": "Algoritma Pencarian",
    "cryptography": "Kriptografi",
    "bubble_title": "Bubble View",
    "visualization_bubble": "Visualisasi Bubble Sort",
    "comparisons": "Perbandingan",
    "swaps": "Pertukaran",
    "time": "Waktu",
    "controls": "Kontrol",
    "start": "Mulai",
    "pause": "Jeda",
    "restart": "Ulangi",
    "shuffle": "Acak",
    "animation_speed": "Kecepatan Animasi",
    "bubble_sort_title": "Bubble Sort",
    "bubble_sort_desc": "Algoritma sorting sederhana berbasis perbandingan.",
    "quick_sort_title": "Quick Sort",
    "quick_sort_desc": "Sorting divide-and-conquer menggunakan pivot.",
    "merge_sort_title": "Merge Sort",
    "merge_sort_desc": "Sorting divide-and-conquer menggunakan penggabungan.",
    "insertion_sort_title": "Insertion Sort",
    "insertion_sort_desc": "Sorting dengan menyisipkan elemen secara berurutan.",
    "selection_sort_title": "Selection Sort",
    "selection_sort_desc": "Sorting dengan memilih elemen minimum.",
    "heap_sort_title": "Heap Sort",
    "heap_sort_desc": "Sorting menggunakan struktur data heap.",
    "dijkstra_title": "Algoritma Dijkstra",
    "dijkstra_desc": "Shortest path menggunakan strategi greedy.",
    "bfs_title": "Breadth-First Search (BFS)",
    "bfs_desc": "Traversal graf menggunakan queue.",
    "dfs_title": "Depth-First Search (DFS)",
    "dfs_desc": "Traversal graf menggunakan stack/rekursi.",
    "bellman_ford_title": "Algoritma Bellman-Ford",
    "bellman_ford_desc": "Shortest path dengan dukungan edge negatif.",
    "floyd_warshall_title": "Algoritma Floyd-Warshall",
    "floyd_warshall_desc": "Shortest path seluruh pasangan node.",
    "kruskal_title": "Kruskal Minimum Spanning Tree",
    "kruskal_desc": "MST menggunakan unionâ€“find.",
    "prim_title": "Prim Minimum Spanning Tree",
    "prim_desc": "MST menggunakan priority queue.",
    "linear_search_title": "Linear Search",
    "linear_search_desc": "Pencarian berurutan satu per satu.",
    "binary_search_title": "Binary Search",
    "binary_search_desc": "Pencarian cepat dengan pembagian dua.",
    "interpolation_search_title": "Interpolation Search",
    "interpolation_search_desc": "Versi lebih efisien dari binary search.",
    "caesar_cipher_title": "Caesar Cipher",
    "caesar_cipher_desc": "Enkripsi klasik dengan menggeser karakter.",
    "vigenere_cipher_title": "Vigenere Cipher",
    "vigenere_cipher_desc": "Enkripsi dengan kunci polyalphabetic.",
    "rsa_title": "RSA",
    "rsa_desc": "Kriptografi modern menggunakan bilangan prima besar.",
    "aes_title": "AES",
    "aes_desc": "Advanced Encryption Standard.",
    "sha256_title": "Hashing SHA-256",
    "sha256_desc": "Algoritma hashing satu arah.",
    "rsa_title_pro": "Enkripsi RSA",
    "rsa_desc_pro": "Keamanan Transaksi Digital (E-Bank)",
    "rsa_desc_pro_short": "Keamanan data dengan kunci publik & privat.",
    "astar_title_pro": "A* Search",
    "astar_desc_pro": "Rute Drone Otonom (Smart City Routing)",
    "astar_desc_pro_short": "Cari rute terpendek dengan cerdas.",
    "astar_title": "A* Pathfinding",
    "astar_desc": "Algoritma pencarian rute.",
    "learning_summary": "Ringkasan Pembelajaran",
    "learning_introduction": "Pengenalan",
    "learning_understanding": "Memahami Bubble Sort",
    "learning_how_it_works": "Cara Kerja",
    "learning_algorithm_steps": "Langkah-langkah Algoritma",
    "learning_complexity": "Kompleksitas Waktu & Ruang",
    "learning_case_study": "Studi Kasus Nyata",
    "learning_step_by_step": "Visualisasi Step-by-Step",
    "learning_code_implementation": "Implementasi Kode (Dart)",
    "learning_output": "Output",
    "learning_run_code": "Jalankan Kode",
    "learning_concept": "Pemahaman Konsep",
    "learning_pros_cons": "Kelebihan & Kekurangan",
    "learning_quiz": "Latihan Soal & Koding",
    "learning_progress": "Progress Pembelajaran",
    "learning_completed_msg": "Selesai! Semua quiz berhasil diselesaikan",
    "learning_time_complexity": "â±ï¸ Kompleksitas Waktu",
    "learning_space_complexity": "ğŸ’¾ Kompleksitas Ruang",
    "learning_real_world": "Contoh Real-World",
    "quiz_label": "Kuis",
    "learning_use_cases": "Use Cases",
    "learning_advantages": "Kelebihan",
    "learning_disadvantages": "Kekurangan",
    "learning_when_to_use": "Kapan Menggunakan",
    "bubble_summary_text": "â€¢ Algoritma pengurutan sederhana berbasis perbandingan\nâ€¢ Membangun array terurut dengan menukar elemen bersebelahan\nâ€¢ Elemen terbesar \"menggelembung\" ke akhir setiap iterasi\nâ€¢ Cocok untuk pembelajaran, tidak untuk produksi",
    "bubble_understanding_text": "Bubble Sort adalah algoritma pengurutan paling sederhana yang bekerja dengan berulang kali menukar elemen yang bersebelahan jika urutannya salah. Nama \"bubble\" berasal dari cara elemen terbesar \"menggelembung\" ke posisi akhir array seperti gelembung naik ke permukaan air.",
    "bubble_step_1": "1. Mulai dari elemen pertama array",
    "bubble_step_2": "2. Bandingkan elemen saat ini dengan elemen berikutnya",
    "bubble_step_3": "3. Jika elemen saat ini lebih besar, tukar posisinya",
    "bubble_step_4": "4. Lanjutkan ke pasangan berikutnya hingga akhir array",
    "bubble_step_5": "5. Setelah satu putaran, elemen terbesar ada di posisi terakhir",
    "bubble_step_6": "6. Ulangi proses untuk n-1 elemen (mengabaikan elemen terakhir)",
    "bubble_step_7": "7. Berhenti jika tidak ada pertukaran dalam satu putaran lengkap",
    "onboarding_step_1_header": "LANGKAH 1 DARI 3",
    "onboarding_step_1_title": "Saksikan Algoritma\nBeraksi",
    "onboarding_step_1_body": "Pahami logika kompleks melalui visualisasi interaktif.\nLihat Bagaimana data diurutkan dan di proses secara realtime di layar anda.",
    "onboarding_step_2_header": "LANGKAH 2 DARI 3",
    "onboarding_step_2_title": "Kuasai Algoritma\ndengan Studi Kasus",
    "onboarding_step_2_subtitle": "Belajar praktis dengan contoh nyata.Jalankan kode, lihat hasilnya, dan pahami cara kerjanya secara mendalam.",
    "onboarding_step_3_header": "SIAP DIMULAI",
    "onboarding_step_3_title": "Siap Meluncur\nke Algo Lab?",
    "onboarding_step_3_body": "Kuasi algoritma, pecahkan tantangan, dan bangun coding masa depan anda.",
    "common_next": "Lanjut",
    "common_login_google": "Lanjutkan dengan Google",
    "common_login": "Login Cepat",
    "common_recommended": "Direkomendasikan",
    "common_skip": "Skip",
    "common_error_prefix": "Error: ",
    "learning_content_unavailable": "Konten tidak tersedia",
    "learning_reset_progress_title": "Reset Progress?",
    "learning_reset_progress_content": "Semua progress dan jawaban kuis akan dihapus.",
    "common_cancel": "Batal",
    "common_reset": "Reset",
    "learning_reset_progress_tooltip": "Reset Progress",
    "learning_unlock_quiz_msg": "Jalankan kode di atas untuk membuka kuis.",
    "learning_hint_prefix": "Petunjuk: ",
    "common_submit": "Kirim",
    "common_debug_console": "KONSOL DEBUG",
    "common_solution_file": "solusi.dart",
    "bubble_time_complexity": "â€¢ Best Case: O(n) - array sudah terurut\nâ€¢ Average Case: O(nÂ²) - array acak\nâ€¢ Worst Case: O(nÂ²) - array terurut terbalik",
    "bubble_space_complexity": "â€¢ O(1) - hanya membutuhkan variabel temporary\nâ€¢ In-place sorting (tidak perlu array tambahan)",
    "bubble_advantage_1": "Sangat mudah dipahami dan diimplementasikan",
    "bubble_advantage_2": "Tidak memerlukan memori tambahan (in-place)",
    "bubble_advantage_3": "Stabil - mempertahankan urutan elemen yang sama",
    "bubble_advantage_4": "Dapat mendeteksi jika array sudah terurut",
    "bubble_advantage_5": "Cocok untuk dataset sangat kecil",
    "bubble_disadvantage_1": "Sangat lambat untuk dataset besar O(nÂ²)",
    "bubble_disadvantage_2": "Tidak efisien dibanding algoritma modern",
    "bubble_disadvantage_3": "Banyak operasi perbandingan dan swap",
    "bubble_disadvantage_4": "Tidak cocok untuk aplikasi production",
    "bubble_disadvantage_5": "Performance buruk bahkan untuk data medium",
    "bubble_visual_step_1": "ğŸ“Š Array awal: [64, 34, 25, 12, 22]",
    "bubble_visual_step_2": "ğŸ”„ Pass 1: Bandingkan pasangan bersebelahan",
    "bubble_visual_step_3": "   64 > 34 â†’ Tukar â†’ [34, 64, 25, 12, 22]",
    "bubble_visual_step_4": "   64 > 25 â†’ Tukar â†’ [34, 25, 64, 12, 22]",
    "bubble_visual_step_5": "   64 > 12 â†’ Tukar â†’ [34, 25, 12, 64, 22]",
    "bubble_visual_step_6": "   64 > 22 â†’ Tukar â†’ [34, 25, 12, 22, 64] âœ“",
    "bubble_visual_step_7": "ğŸ”„ Pass 2: Elemen terbesar sudah di akhir",
    "bubble_visual_step_8": "   34 > 25 â†’ Tukar â†’ [25, 34, 12, 22, 64]",
    "bubble_visual_step_9": "   34 > 12 â†’ Tukar â†’ [25, 12, 34, 22, 64]",
    "bubble_visual_step_10": "   34 > 22 â†’ Tukar â†’ [25, 12, 22, 34, 64] âœ“",
    "bubble_visual_step_11": "ğŸ”„ Pass 3-4: Proses berlanjut...",
    "bubble_visual_step_12": "âœ… Hasil akhir: [12, 22, 25, 34, 64]",
    "bubble_use_cases": "â€¢ Pembelajaran algoritma sorting\nâ€¢ Dataset sangat kecil (< 10 elemen)\nâ€¢ Hampir terurut (dengan optimasi)\nâ€¢ Demonstrasi konsep sorting",
    "bubble_real_world": "Contoh: Mengurutkan 5 nilai ujian siswa\nInput: [85, 72, 90, 68, 95]\nOutput: [68, 72, 85, 90, 95]",
    "bubble_quiz_1_question": "Soal 1: Implementasikan fungsi bubbleSort dasar",
    "bubble_quiz_1_hint": "Gunakan nested loop. Loop luar untuk pass, loop dalam untuk perbandingan.",
    "bubble_quiz_2_question": "Soal 2: Tambahkan optimasi early termination",
    "bubble_quiz_2_hint": "Gunakan boolean flag \"swapped\". Jika tidak ada swap, break!",
    "bubble_quiz_3_question": "Soal 3: Modifikasi untuk descending order",
    "bubble_quiz_3_hint": "Ubah operator dari > menjadi < untuk descending",
    "quick_summary": "â€¢ Algoritma divide-and-conquer yang sangat efisien\nâ€¢ Memilih pivot dan membagi array menjadi dua bagian\nâ€¢ Elemen lebih kecil di kiri, lebih besar di kanan pivot\nâ€¢ Salah satu algoritma sorting tercepat dalam praktik",
    "quick_understanding": "Quick Sort adalah algoritma pengurutan yang menggunakan strategi divide-and-conquer. Algoritma ini memilih sebuah elemen sebagai \"pivot\" dan mempartisi array sehingga semua elemen yang lebih kecil dari pivot berada di sebelah kiri, dan yang lebih besar di sebelah kanan. Proses ini dilakukan secara rekursif.",
    "quick_step_1": "1. Pilih elemen pivot (biasanya elemen terakhir)",
    "quick_step_2": "2. Partisi array: elemen < pivot di kiri, > pivot di kanan",
    "quick_step_3": "3. Tempatkan pivot di posisi yang benar",
    "quick_step_4": "4. Rekursif sort bagian kiri pivot",
    "quick_step_5": "5. Rekursif sort bagian kanan pivot",
    "quick_step_6": "6. Base case: array dengan 0 atau 1 elemen sudah terurut",
    "quick_time_complexity": "â€¢ Best Case: O(n log n)\nâ€¢ Average Case: O(n log n)\nâ€¢ Worst Case: O(nÂ²)",
    "quick_space_complexity": "â€¢ O(log n) - untuk rekursi stack",
    "quick_advantage_1": "Sangat cepat dalam praktik",
    "quick_advantage_2": "In-place sorting",
    "quick_advantage_3": "Cache-friendly",
    "quick_advantage_4": "Mudah diparalelkan",
    "quick_disadvantage_1": "Tidak stabil",
    "quick_disadvantage_2": "Worst case O(nÂ²)",
    "quick_disadvantage_3": "Rekursif (stack overflow risk)",
    "quick_visual_step_1": "ğŸ“Š Array: [64, 34, 25, 12, 22]",
    "quick_visual_step_2": "ğŸ¯ Pivot: 22",
    "quick_visual_step_3": "ğŸ“ Partisi: [12] | 22 | [64,34,25]",
    "quick_visual_step_4": "ğŸ”„ Rekursif...",
    "quick_visual_step_5": "âœ… Hasil: [12, 22, 25, 34, 64]",
    "quick_quiz_1_question": "Implementasikan partition",
    "quick_quiz_1_hint": "Gunakan pivot, iterasi dan swap",
    "quick_use_cases": "â€¢ Sorting dataset besar\nâ€¢ Sistem operasi\nâ€¢ Database optimization",
    "quick_real_world": "Quick Sort: ~20ms untuk 1M records\nBubble Sort: ~30 detik",
    "merge_summary": "â€¢ Algoritma divide-and-conquer yang stabil\nâ€¢ Membagi array menjadi dua bagian hingga ukuran 1\nâ€¢ Menggabungkan kembali dengan urutan yang benar\nâ€¢ Konsisten O(n log n) untuk semua kasus",
    "merge_understanding": "Merge Sort membagi array menjadi dua bagian, mengurutkan masing-masing bagian secara rekursif, kemudian menggabungkan (merge) kedua bagian yang sudah terurut.",
    "merge_step_1": "1. Bagi array menjadi dua bagian",
    "merge_step_2": "2. Rekursif sort bagian kiri",
    "merge_step_3": "3. Rekursif sort bagian kanan",
    "merge_step_4": "4. Gabungkan (merge) kedua bagian",
    "merge_time_complexity": "â€¢ Best/Avg/Worst: O(n log n) - KONSISTEN!",
    "merge_space_complexity": "â€¢ O(n) - membutuhkan array temporary",
    "merge_advantage_1": "Konsisten O(n log n)",
    "merge_advantage_2": "Stabil",
    "merge_advantage_3": "Predictable performance",
    "merge_disadvantage_1": "Membutuhkan O(n) extra space",
    "merge_disadvantage_2": "Tidak in-place",
    "merge_visual_step_1": "ğŸ“Š Array: [64, 34, 25, 12, 22]",
    "merge_visual_step_2": "âœ‚ï¸ Bagi: [64,34,25] [12,22]",
    "merge_visual_step_3": "ğŸ”€ Merge: [12,22,25,34,64]",
    "merge_quiz_1_question": "Implementasikan merge",
    "merge_quiz_1_hint": "Buat 2 array temp, bandingkan dan gabungkan",
    "merge_use_cases": "â€¢ Sorting linked list\nâ€¢ External sorting\nâ€¢ Stable sorting requirement",
    "merge_real_world": "Sorting 1GB file: Bagi jadi chunks, sort, merge",
    "insertion_summary": "â€¢ Membangun array terurut satu elemen pada satu waktu\nâ€¢ Menyisipkan setiap elemen ke posisi yang benar\nâ€¢ Efisien untuk array kecil atau hampir terurut\nâ€¢ Algoritma sorting yang stabil",
    "insertion_understanding": "Insertion Sort bekerja seperti cara kita mengurutkan kartu di tangan. Kita mengambil satu kartu dan menyisipkannya ke posisi yang benar di antara kartu-kartu yang sudah terurut.",
    "insertion_step_1": "1. Mulai dari elemen kedua (index 1)",
    "insertion_step_2": "2. Simpan elemen saat ini sebagai \"key\"",
    "insertion_step_3": "3. Bandingkan key dengan elemen sebelumnya",
    "insertion_step_4": "4. Geser elemen yang lebih besar ke kanan",
    "insertion_step_5": "5. Sisipkan key di posisi yang benar",
    "insertion_step_6": "6. Ulangi untuk semua elemen",
    "insertion_time_complexity": "â€¢ Best Case: O(n) - array sudah terurut\nâ€¢ Average Case: O(nÂ²)\nâ€¢ Worst Case: O(nÂ²) - array terurut terbalik",
    "insertion_space_complexity": "â€¢ O(1) - in-place sorting",
    "insertion_advantage_1": "Sederhana dan mudah diimplementasikan",
    "insertion_advantage_2": "Efisien untuk array kecil (n < 50)",
    "insertion_advantage_3": "Efisien untuk array hampir terurut",
    "insertion_advantage_4": "Stabil dan in-place",
    "insertion_advantage_5": "Online algorithm (bisa sort data yang datang bertahap)",
    "insertion_disadvantage_1": "O(nÂ²) untuk dataset besar",
    "insertion_disadvantage_2": "Tidak efisien untuk array acak besar",
    "insertion_disadvantage_3": "Banyak operasi shift",
    "insertion_visual_step_1": "ğŸ“Š Array: [12, 11, 13, 5, 6]",
    "insertion_visual_step_2": "ğŸ¯ Key=11: [11, 12, 13, 5, 6]",
    "insertion_visual_step_3": "ğŸ¯ Key=13: [11, 12, 13, 5, 6] (sudah benar)",
    "insertion_visual_step_4": "ğŸ¯ Key=5: Geser 13,12,11 â†’ [5, 11, 12, 13, 6]",
    "insertion_visual_step_5": "ğŸ¯ Key=6: Geser 13,12,11 â†’ [5, 6, 11, 12, 13]",
    "insertion_visual_step_6": "âœ… Selesai!",
    "insertion_quiz_1_question": "Soal 1: Implementasikan Insertion Sort",
    "insertion_quiz_1_hint": "Loop dari index 1, simpan key, geser elemen > key ke kanan",
    "insertion_use_cases": "â€¢ Array kecil (< 50 elemen)\nâ€¢ Array hampir terurut\nâ€¢ Online sorting (data streaming)\nâ€¢ Hybrid sorting (dengan Quick/Merge Sort)",
    "insertion_real_world": "Contoh: Mengurutkan kartu remi di tangan\nAmbil kartu satu per satu dan sisipkan di posisi yang benar",
    "selection_summary": "â€¢ Mencari elemen minimum dan menukarnya dengan elemen pertama\nâ€¢ Ulangi untuk sisa array\nâ€¢ Sederhana tapi tidak efisien untuk dataset besar\nâ€¢ Melakukan minimal swap (n-1 swap)",
    "selection_understanding": "Selection Sort bekerja dengan berulang kali mencari elemen terkecil dari bagian array yang belum terurut dan menukarnya dengan elemen pertama dari bagian tersebut.",
    "selection_step_1": "1. Cari elemen minimum di array",
    "selection_step_2": "2. Tukar dengan elemen pertama",
    "selection_step_3": "3. Cari elemen minimum di sisa array (mulai index 1)",
    "selection_step_4": "4. Tukar dengan elemen kedua",
    "selection_step_5": "5. Ulangi hingga array terurut",
    "selection_time_complexity": "â€¢ Best Case: O(nÂ²)\nâ€¢ Average Case: O(nÂ²)\nâ€¢ Worst Case: O(nÂ²) - SELALU O(nÂ²)!",
    "selection_space_complexity": "â€¢ O(1) - in-place sorting",
    "selection_advantage_1": "Sederhana dan mudah dipahami",
    "selection_advantage_2": "Minimal swap operations (n-1 swap)",
    "selection_advantage_3": "In-place sorting",
    "selection_advantage_4": "Performa konsisten (selalu O(nÂ²))",
    "selection_disadvantage_1": "Selalu O(nÂ²) bahkan untuk array terurut",
    "selection_disadvantage_2": "Tidak stabil",
    "selection_disadvantage_3": "Tidak efisien untuk dataset besar",
    "selection_disadvantage_4": "Tidak adaptive (tidak memanfaatkan data terurut)",
    "selection_visual_step_1": "ğŸ“Š Array: [64, 25, 12, 22, 11]",
    "selection_visual_step_2": "ğŸ” Cari min: 11 â†’ Swap dengan 64",
    "selection_visual_step_3": "   [11, 25, 12, 22, 64]",
    "selection_visual_step_4": "ğŸ” Cari min: 12 â†’ Swap dengan 25",
    "selection_visual_step_5": "   [11, 12, 25, 22, 64]",
    "selection_visual_step_6": "ğŸ” Cari min: 22 â†’ Swap dengan 25",
    "selection_visual_step_7": "   [11, 12, 22, 25, 64]",
    "selection_visual_step_8": "âœ… Selesai!",
    "selection_quiz_1_question": "Soal 1: Implementasikan Selection Sort",
    "selection_quiz_1_hint": "Loop luar untuk posisi, loop dalam cari minimum, lalu swap",
    "selection_use_cases": "â€¢ Ketika swap operation mahal\nâ€¢ Array kecil\nâ€¢ Pembelajaran algoritma\nâ€¢ Memori terbatas (in-place)",
    "selection_real_world": "Contoh: Memilih 5 siswa terpendek dari kelas\nScan semua siswa, pilih yang terpendek, ulangi",
    "heap_summary": "â€¢ Menggunakan struktur data Binary Heap\nâ€¢ Membangun max heap, lalu extract max berulang kali\nâ€¢ In-place dan O(n log n) untuk semua kasus\nâ€¢ Tidak stabil tapi efisien",
    "heap_understanding": "Heap Sort menggunakan struktur data Binary Heap untuk mengurutkan array. Algoritma ini membangun max heap dari array, kemudian berulang kali mengambil elemen maksimum (root) dan memperbaiki heap.",
    "heap_step_1": "1. Bangun max heap dari array",
    "heap_step_2": "2. Swap root (max) dengan elemen terakhir",
    "heap_step_3": "3. Kurangi ukuran heap",
    "heap_step_4": "4. Heapify root untuk memperbaiki heap",
    "heap_step_5": "5. Ulangi langkah 2-4 hingga heap kosong",
    "heap_time_complexity": "â€¢ Best Case: O(n log n)\nâ€¢ Average Case: O(n log n)\nâ€¢ Worst Case: O(n log n) - KONSISTEN!",
    "heap_space_complexity": "â€¢ O(1) - in-place sorting",
    "heap_advantage_1": "Konsisten O(n log n) untuk semua kasus",
    "heap_advantage_2": "In-place sorting (O(1) space)",
    "heap_advantage_3": "Tidak ada worst case O(nÂ²)",
    "heap_advantage_4": "Cocok untuk sistem real-time",
    "heap_disadvantage_1": "Tidak stabil",
    "heap_disadvantage_2": "Lebih lambat dari Quick Sort dalam praktik",
    "heap_disadvantage_3": "Cache-unfriendly (akses random)",
    "heap_disadvantage_4": "Kompleks untuk dipahami",
    "heap_visual_step_1": "ğŸ“Š Array: [12, 11, 13, 5, 6, 7]",
    "heap_visual_step_2": "ğŸ—ï¸ Build max heap: [13, 11, 12, 5, 6, 7]",
    "heap_visual_step_3": "ğŸ”„ Swap 13 dengan 7: [7, 11, 12, 5, 6, 13]",
    "heap_visual_step_4": "ğŸ”§ Heapify: [12, 11, 7, 5, 6, 13]",
    "heap_visual_step_5": "ğŸ”„ Swap 12 dengan 6: [6, 11, 7, 5, 12, 13]",
    "heap_visual_step_6": "ğŸ”§ Heapify: [11, 6, 7, 5, 12, 13]",
    "heap_visual_step_7": "ğŸ”„ Proses berlanjut...",
    "heap_visual_step_8": "âœ… Hasil: [5, 6, 7, 11, 12, 13]",
    "heap_quiz_1_question": "Soal 1: Implementasikan fungsi heapify",
    "heap_quiz_1_hint": "Cari largest antara i, left child, right child. Swap dan rekursif",
    "heap_use_cases": "â€¢ Sistem real-time (predictable performance)\nâ€¢ Embedded systems (O(1) space)\nâ€¢ Priority queue implementation\nâ€¢ Ketika worst case O(n log n) diperlukan",
    "heap_real_world": "Contoh: Task scheduling di OS\nHeap untuk priority queue, selalu ambil task prioritas tertinggi",
    "linear_summary": "â€¢ Pencarian paling sederhana dengan memeriksa setiap elemen\nâ€¢ Tidak memerlukan array terurut\nâ€¢ Cocok untuk array kecil atau pencarian satu kali\nâ€¢ Kompleksitas O(n)",
    "linear_understanding": "Linear Search adalah algoritma pencarian paling dasar yang memeriksa setiap elemen dalam array satu per satu hingga menemukan elemen yang dicari atau mencapai akhir array.",
    "linear_step_1": "1. Mulai dari elemen pertama array",
    "linear_step_2": "2. Bandingkan elemen saat ini dengan target",
    "linear_step_3": "3. Jika sama, return index",
    "linear_step_4": "4. Jika tidak, lanjut ke elemen berikutnya",
    "linear_step_5": "5. Ulangi hingga menemukan atau mencapai akhir",
    "linear_step_6": "6. Return -1 jika tidak ditemukan",
    "linear_time_complexity": "â€¢ Best Case: O(1) - elemen pertama\nâ€¢ Average Case: O(n) - elemen di tengah\nâ€¢ Worst Case: O(n) - elemen terakhir atau tidak ada",
    "linear_space_complexity": "â€¢ O(1) - hanya butuh variabel index",
    "linear_advantage_1": "Sangat sederhana dan mudah diimplementasikan",
    "linear_advantage_2": "Tidak memerlukan array terurut",
    "linear_advantage_3": "Cocok untuk array kecil",
    "linear_advantage_4": "Cocok untuk pencarian satu kali",
    "linear_advantage_5": "Bekerja pada semua jenis data",
    "linear_disadvantage_1": "Lambat untuk array besar O(n)",
    "linear_disadvantage_2": "Tidak efisien untuk pencarian berulang",
    "linear_disadvantage_3": "Harus memeriksa semua elemen dalam worst case",
    "linear_visual_step_1": "ğŸ“Š Array: [64, 34, 25, 12, 22, 11, 90]",
    "linear_visual_step_2": "ğŸ¯ Target: 22",
    "linear_visual_step_3": "ğŸ‘‰ Index 0: 64 â‰  22",
    "linear_visual_step_4": "ğŸ‘‰ Index 1: 34 â‰  22",
    "linear_visual_step_5": "ğŸ‘‰ Index 2: 25 â‰  22",
    "linear_visual_step_6": "ğŸ‘‰ Index 3: 12 â‰  22",
    "linear_visual_step_7": "ğŸ‘‰ Index 4: 22 = 22 âœ…",
    "linear_visual_step_8": "âœ… Ditemukan di index 4!",
    "linear_quiz_1_question": "Soal 1: Implementasikan Linear Search",
    "linear_quiz_1_hint": "Loop dari 0 hingga length-1, bandingkan setiap elemen dengan target",
    "linear_quiz_2_question": "Soal 2: Modifikasi untuk mencari semua kemunculan",
    "linear_quiz_2_hint": "Buat list kosong, tambahkan setiap index yang cocok",
    "linear_quiz_3_question": "Soal 3: Implementasikan dengan sentinel (optimasi)",
    "linear_quiz_3_hint": "Simpan elemen terakhir, set sebagai target, loop tanpa cek bound",
    "linear_use_cases": "â€¢ Array kecil (< 100 elemen)\nâ€¢ Array tidak terurut\nâ€¢ Pencarian satu kali\nâ€¢ Data yang jarang dicari",
    "linear_real_world": "Contoh: Mencari nama di daftar 10 tamu undangan\nLinear search sudah cukup cepat untuk ukuran ini",
    "binary_summary": "â€¢ Pencarian efisien pada array terurut\nâ€¢ Membagi array menjadi dua bagian setiap iterasi\nâ€¢ Kompleksitas O(log n) - sangat cepat!\nâ€¢ Memerlukan array terurut terlebih dahulu",
    "binary_understanding": "Binary Search adalah algoritma pencarian yang sangat efisien untuk array terurut. Algoritma ini bekerja dengan membagi array menjadi dua bagian dan membuang setengah yang tidak mungkin berisi target.",
    "binary_step_1": "1. Set left = 0, right = n-1",
    "binary_step_2": "2. Hitung mid = (left + right) / 2",
    "binary_step_3": "3. Jika arr[mid] == target, return mid",
    "binary_step_4": "4. Jika arr[mid] < target, cari di kanan (left = mid + 1)",
    "binary_step_5": "5. Jika arr[mid] > target, cari di kiri (right = mid - 1)",
    "binary_step_6": "6. Ulangi hingga menemukan atau left > right",
    "binary_time_complexity": "â€¢ Best Case: O(1) - elemen tengah\nâ€¢ Average Case: O(log n)\nâ€¢ Worst Case: O(log n) - sangat efisien!",
    "binary_space_complexity": "â€¢ Iteratif: O(1)\nâ€¢ Rekursif: O(log n) - untuk call stack",
    "binary_advantage_1": "Sangat cepat O(log n)",
    "binary_advantage_2": "Efisien untuk array besar",
    "binary_advantage_3": "Cocok untuk pencarian berulang",
    "binary_advantage_4": "Dapat diimplementasikan iteratif atau rekursif",
    "binary_disadvantage_1": "Memerlukan array terurut",
    "binary_disadvantage_2": "Tidak efisien jika sering insert/delete",
    "binary_disadvantage_3": "Overhead sorting jika array belum terurut",
    "binary_visual_step_1": "ğŸ“Š Array terurut: [11, 12, 22, 25, 34, 64, 90]",
    "binary_visual_step_2": "ğŸ¯ Target: 25",
    "binary_visual_step_3": "ğŸ“ L=0, R=6, M=3: arr[3]=25",
    "binary_visual_step_4": "âœ… Ditemukan langsung!",
    "binary_visual_step_5": "",
    "binary_visual_step_6": "Contoh lain - Target: 90",
    "binary_visual_step_7": "ğŸ“ L=0, R=6, M=3: arr[3]=25 < 90 â†’ Kanan",
    "binary_visual_step_8": "ğŸ“ L=4, R=6, M=5: arr[5]=64 < 90 â†’ Kanan",
    "binary_visual_step_9": "ğŸ“ L=6, R=6, M=6: arr[6]=90 âœ…",
    "binary_quiz_1_question": "Soal 1: Implementasikan Binary Search iteratif",
    "binary_quiz_1_hint": "While left <= right, hitung mid, bandingkan, update left/right",
    "binary_quiz_2_question": "Soal 2: Implementasikan Binary Search rekursif",
    "binary_quiz_2_hint": "Base case: left > right. Hitung mid, rekursif kiri atau kanan",
    "binary_quiz_3_question": "Soal 3: Cari index pertama dari elemen yang muncul berulang",
    "binary_quiz_3_hint": "Saat ketemu, simpan result tapi terus cari di kiri",
    "binary_use_cases": "â€¢ Array terurut besar\nâ€¢ Pencarian berulang\nâ€¢ Database indexing\nâ€¢ Dictionary/phonebook lookup",
    "binary_real_world": "Contoh: Mencari kata di kamus 100,000 kata\nLinear: ~50,000 perbandingan\nBinary: ~17 perbandingan (logâ‚‚ 100,000)",
    "interpolation_summary": "â€¢ Versi lebih pintar dari Binary Search\nâ€¢ Menebak posisi berdasarkan nilai target\nâ€¢ Sangat efisien untuk data terdistribusi uniform\nâ€¢ Kompleksitas O(log log n) untuk data uniform",
    "interpolation_understanding": "Interpolation Search adalah peningkatan dari Binary Search yang menebak posisi elemen berdasarkan nilainya, seperti cara kita mencari kata di kamus (langsung ke huruf yang sesuai, bukan selalu ke tengah).",
    "interpolation_step_1": "1. Hitung posisi dengan interpolasi linear",
    "interpolation_step_2": "2. pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])",
    "interpolation_step_3": "3. Jika arr[pos] == target, return pos",
    "interpolation_step_4": "4. Jika arr[pos] < target, cari di kanan",
    "interpolation_step_5": "5. Jika arr[pos] > target, cari di kiri",
    "interpolation_step_6": "6. Ulangi hingga menemukan atau range invalid",
    "interpolation_time_complexity": "â€¢ Best Case: O(1)\nâ€¢ Average Case: O(log log n) - untuk data uniform\nâ€¢ Worst Case: O(n) - untuk data non-uniform",
    "interpolation_space_complexity": "â€¢ O(1) - iteratif",
    "interpolation_advantage_1": "Lebih cepat dari Binary Search untuk data uniform",
    "interpolation_advantage_2": "O(log log n) sangat efisien",
    "interpolation_advantage_3": "Cocok untuk data numerik terdistribusi merata",
    "interpolation_disadvantage_1": "Memerlukan data terurut dan uniform",
    "interpolation_disadvantage_2": "Worst case O(n) untuk data skewed",
    "interpolation_disadvantage_3": "Lebih kompleks dari Binary Search",
    "interpolation_disadvantage_4": "Bisa overflow untuk nilai besar",
    "interpolation_visual_step_1": "ğŸ“Š Array: [10, 20, 30, 40, 50, 60, 70, 80, 90]",
    "interpolation_visual_step_2": "ğŸ¯ Target: 70",
    "interpolation_visual_step_3": "ğŸ§® Interpolasi: pos = 0 + (70-10)*(8-0)/(90-10)",
    "interpolation_visual_step_4": "   pos = 0 + 60*8/80 = 0 + 6 = 6",
    "interpolation_visual_step_5": "ğŸ“ Cek arr[6] = 70 âœ…",
    "interpolation_visual_step_6": "âœ… Langsung ketemu!",
    "interpolation_visual_step_7": "",
    "interpolation_visual_step_8": "Binary Search butuh 2-3 iterasi",
    "interpolation_visual_step_9": "Interpolation: 1 iterasi!",
    "interpolation_quiz_1_question": "Soal 1: Implementasikan Interpolation Search",
    "interpolation_quiz_1_hint": "Hitung pos dengan formula interpolasi, lalu mirip binary search",
    "interpolation_use_cases": "â€¢ Data numerik terdistribusi uniform\nâ€¢ Database dengan sequential keys\nâ€¢ Pencarian di range besar dengan data merata\nâ€¢ Phonebook dengan nama terdistribusi merata",
    "interpolation_real_world": "Contoh: Mencari halaman 750 di buku 1000 halaman\nInterpolation: Langsung buka ~75% dari buku\nBinary: Buka tengah (500), lalu 750, dst",
    "summary_title": "Ringkasan Anda",
    "summary_this_week": "Minggu Ini",
    "summary_completed": "SELESAI",
    "summary_total_progress": "Total Progress",
    "summary_total_xp": "TOTAL XP",
    "summary_streak": "STREAK",
    "summary_xp_today": "XP hari ini",
    "summary_today": "hari ini",
    "last_learned_title": "Terakhir Dipelajari",
    "last_learned_time_ago": "jam lalu",
    "catalog_title": "Katalog Visualisasi",
    "view_all": "Lihat Semua",
    "no_learning_yet": "Mulai belajar untuk melihat progress Anda!",
    "profile_title": "Profile",
    "profile_level": "Level",
    "profile_master": "Master Algoritma",
    "profile_progress_summary": "RINGKASAN PROGRESS",
    "profile_detail": "Detail >",
    "profile_algorithms": "Algoritma",
    "profile_total_xp": "Total XP",
    "profile_streak": "Streak",
    "profile_achievements": "Prestasi & Lencana",
    "profile_achievements_subtitle": "Lihat semua pencapaian anda",
    "profile_account_settings": "PENGATURAN AKUN",
    "profile_edit": "Edit Profil",
    "profile_edit_subtitle": "Ubah foto & info dasar",
    "profile_security": "Keamanan",
    "profile_security_subtitle": "Password & 2FA",
    "profile_notifications": "Notifikasi",
    "profile_notifications_subtitle": "Atur preferensi",
    "profile_language": "Bahasa",
    "profile_language_subtitle": "Indonesia (ID)",
    "profile_logout": "Keluar Akun",
    "profile_version": "Versi",
    "achievements_title": "Prestasi & Lencana",
    "level": "LEVEL",
    "master_algorithm": "Master Algoritma",
    "badge_collection": "Koleksi Lencana",
    "unlocked": "Terbuka",
    "latest_achievements": "Pencapaian Terbaru",
    "badge_algo_novice": "Pemula Algo",
    "badge_algo_novice_desc": "Capai 100 XP",
    "badge_algo_master": "Master Algo",
    "badge_algo_master_desc": "Selesaikan 50 algoritma",
    "badge_speed_demon": "Iblis Kecepatan",
    "badge_speed_demon_desc": "Selesaikan dalam 30 detik",
    "badge_elite_pro": "Pro Elit",
    "badge_elite_pro_desc": "Capai level 10",
    "badge_mentor": "Mentor",
    "badge_mentor_desc": "Bantu 5 pembelajar",
    "achievement_sorting_10": "Selesai 10 Sorting Algo",
    "achievement_sorting_10_desc": "Selesaikan 10 algoritma sorting",
    "achievement_first_algo": "Langkah Pertama",
    "achievement_first_algo_desc": "Selesaikan algoritma pertama Anda",
    "achievement_sorting_master": "Master Sorting",
    "achievement_sorting_master_desc": "Selesaikan 5 algoritma sorting",
    "achievement_streak_hero": "Pahlawan Streak",
    "achievement_streak_hero_desc": "Capai streak 7 hari",
    "achievement_dedicated_learner": "Pembelajar Setia",
    "achievement_dedicated_learner_desc": "Selesaikan 10 sesi pembelajaran",
    "achievement_streak_30": "Streak 30 Hari",
    "achievement_streak_30_desc": "Pertahankan streak 30 hari",
    "achievement_master_return": "Master Return",
    "achievement_master_return_desc": "Selesaikan 5 modul lanjutan",
    "no_learning_subtitle": "Mulai perjalanan Anda menguasai algoritma",
    "start_learning_now": "Mulai Belajar Sekarang",
    "bottom_sheet_title_1": "Pilih Visualisasi",
    "bottom_sheet_title_2": "Algoritma",
    "bottom_sheet_search": "Cari Algoritma...",
    "bottom_sheet_start": "Mulai Visualisasi",
    "bottom_sheet_detail": "Lihat Detail Lengkap",
    "menu_home": "Beranda",
    "menu_learn": "Belajar",
    "menu_profile": "Profil",
    "module_locked": "TERKUNCI",
    "module_completed": "SELESAI",
    "interactive_code": "Kode Interaktif",
    "case_study": "Studi Kasus",
    "quiz_correct_msg": "âœ… Benar! Kode Anda sudah tepat.",
    "quiz_incorrect_msg": "âŒ Belum tepat. Coba lagi!",
    "quiz_expected_msg": "Yang diharapkan:",
    "quiz_hint": "Petunjuk:",
    "quiz_default_explanation": "Implementasi Anda sudah sesuai dengan solusi yang diharapkan!",
    "error_content_not_found": "Konten untuk algoritma {algorithmId} tidak ditemukan",
    "quiz_explanation": "Penjelasan:",
    "lab_bubble_title": "Bubble Sort",
    "lab_bubble_desc": "Simulasi beban sistem yang 'naik' ke permukaan berdasarkan prioritas. Benda berat (nilai besar) akan tenggelam ke bawah.",
    "lab_bubble_desc_short": "Urutkan data dengan menggelembungkan nilai terbesar.",
    "lab_selection_title": "Selection Sort",
    "lab_selection_desc": "Memilih barang paling efisien dari rak untuk dipindahkan ke jalur pengiriman utama satu per satu.",
    "lab_selection_desc_short": "Pilih nilai terkecil dan letakkan di posisi awal.",
    "lab_insertion_title": "Insertion Sort",
    "lab_insertion_desc": "Menyisipkan data baru ke dalam katalog yang sudah terurut, seperti menyusun buku atau inventaris toko.",
    "lab_insertion_desc_short": "Sisipkan setiap elemen ke posisi yang benar.",
    "lab_quick_title": "Quick Sort",
    "lab_quick_desc": "Membagi dataset raksasa menjadi partisi kecil (shard) menggunakan Pivot Point untuk pemrosesan paralel.",
    "lab_quick_desc_short": "Bagi data jadi dua bagian menggunakan pivot.",
    "lab_simulation_done": "Simulasi Selesai",
    "lab_result_msg": "Data berhasil dioptimasi dengan {swaps} pertukaran dan {comparisons} perbandingan.",
    "lab_active_visualization": "VISUALISASI AKTIF",
    "lab_pathfinding_title": "Lab Pathfinding",
    "lab_case_study_logistics_title": "STUDI KASUS: OPTIMASI LOGISTIK",
    "lab_case_study_logistics_body": "Mencari rute paling efisien untuk drone pengiriman otonom di grid kota pintar dengan menghindari rintangan.",
    "lab_start_logistics": "MULAI LOGISTIK",
    "lab_reset_grid": "RESET GRID",
    "lab_clear_obstacles": "HAPUS SEMUA RINTANGAN",
    "lab_case_study": "STUDI KASUS",
    "lab_run": "Jalankan",
    "lab_shuffle": "Acak Ulang",
    "lab_speed": "Kecepatan Simulasi",
    "lab_searching_min": "Mencari Nilai Minimum...",
    "lab_pivot": "PIVOT",
    "global_rank_top_1": "Top 1% Global",
    "global_rank_top_5": "Top 5% Global",
    "global_rank_top_10": "Top 10% Global",
    "global_rank_top_25": "Top 25% Global",
    "time_days_ago": "hari yang lalu",
    "time_hours_ago": "jam yang lalu",
    "time_minutes_ago": "menit yang lalu",
    "time_seconds_ago": "detik yang lalu",
    "time_just_now": "baru saja",
    "time_recently": "baru-baru ini",
    "badge_unlocked_title": "LENCANA BARU TERBUKA!",
    "collect_now": "Ambil Sekarang",
    "rank_novice": "Pemula",
    "rank_apprentice": "Pelajar",
    "rank_specialist": "Spesialis",
    "rank_elite_pro": "Elite Pro",
    "rank_master": "Master Algoritma",
    "notification_badge_unlocked_title": "Lencana Terbuka!",
    "notification_badge_unlocked_body": "Selamat! Kamu telah mendapatkan lencana {name}.",
    "notification_achievement_reached_title": "Pencapaian Berhasil!",
    "notification_achievement_reached_body": "Luar biasa! Kamu telah menyelesaikan: {name}",
    "bfs_summary": "â€¢ Traversal graf level-by-level menggunakan queue\nâ€¢ Mengunjungi semua tetangga sebelum ke level berikutnya\nâ€¢ Menemukan shortest path di unweighted graph\nâ€¢ Kompleksitas O(V + E)",
    "bfs_understanding": "BFS (Breadth-First Search) adalah algoritma traversal graf yang mengunjungi node level demi level. Dimulai dari node awal, kunjungi semua tetangganya, lalu tetangga dari tetangga, dan seterusnya. Menggunakan queue (FIFO).",
    "bfs_step_1": "1. Mulai dari node awal, masukkan ke queue",
    "bfs_step_2": "2. Tandai node sebagai visited",
    "bfs_step_3": "3. Dequeue node, kunjungi node tersebut",
    "bfs_step_4": "4. Enqueue semua tetangga yang belum visited",
    "bfs_step_5": "5. Tandai tetangga sebagai visited",
    "bfs_step_6": "6. Ulangi langkah 3-5 hingga queue kosong",
    "bfs_time_complexity": "â€¢ O(V + E) dimana V = vertices, E = edges\nâ€¢ Setiap vertex dan edge dikunjungi satu kali",
    "bfs_space_complexity": "â€¢ O(V) - untuk queue dan visited set",
    "bfs_advantage_1": "Menemukan shortest path di unweighted graph",
    "bfs_advantage_2": "Level-order traversal",
    "bfs_advantage_3": "Cocok untuk graf yang tidak terlalu dalam",
    "bfs_advantage_4": "Dapat menemukan connected components",
    "bfs_disadvantage_1": "Membutuhkan banyak memori untuk graf yang lebar",
    "bfs_disadvantage_2": "Tidak optimal untuk graf yang sangat dalam",
    "bfs_disadvantage_3": "Tidak bisa handle weighted graph untuk shortest path",
    "bfs_visual_step_1": "ğŸ“Š Struktur Graf:",
    "bfs_visual_step_2": "0 sebagai root, terhubung ke 1 dan 2.",
    "bfs_visual_step_3": "ğŸ”„ BFS dari 0:",
    "bfs_visual_step_4": "Level 0: [0] | Level 1: [1, 2] | Level 2: [3, 4]",
    "bfs_visual_step_5": "âœ… Urutan Kunjungan: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 4",
    "bfs_quiz_1_question": "Soal 1: Implementasikan BFS",
    "bfs_quiz_1_hint": "Gunakan Queue dan Set visited. Dequeue node, kunjungi, lalu enqueue tetangganya.",
    "bfs_use_cases": "â€¢ Shortest path di unweighted graph\nâ€¢ Social network (friends of friends)\nâ€¢ Web crawler\nâ€¢ Navigasi GPS (unweighted)",
    "bfs_real_world": "Contoh: Facebook \"Orang yang Mungkin Anda Kenal\"\nBFS level 2-3 dari profil Anda untuk rekomendasi teman.",
    "dfs_summary": "â€¢ Traversal graf depth-first menggunakan stack/rekursi\nâ€¢ Mengeksplorasi sedalam mungkin sebelum backtrack\nâ€¢ Cocok untuk deteksi cycle dan topological sort\nâ€¢ Kompleksitas O(V + E)",
    "dfs_understanding": "DFS (Depth-First Search) adalah algoritma traversal graf yang mengeksplorasi sedalam mungkin di setiap cabang sebelum backtrack. Menggunakan stack (atau rekursi yang implisit menggunakan call stack).",
    "dfs_step_1": "1. Mulai dari node awal",
    "dfs_step_2": "2. Tandai node sebagai visited",
    "dfs_step_3": "3. Kunjungi node tersebut",
    "dfs_step_4": "4. Untuk setiap tetangga yang belum visited:",
    "dfs_step_5": "5. Rekursif DFS ke tetangga",
    "dfs_step_6": "6. Backtrack jika semua tetangga sudah visited",
    "dfs_time_complexity": "â€¢ O(V + E) dimana V = vertices, E = edges",
    "dfs_space_complexity": "â€¢ O(V) - untuk rekursi stack dan visited set",
    "dfs_advantage_1": "Memori lebih efisien untuk graf yang dalam",
    "dfs_advantage_2": "Cocok untuk deteksi cycle",
    "dfs_advantage_3": "Topological sorting",
    "dfs_advantage_4": "Pathfinding dengan backtracking",
    "dfs_disadvantage_1": "Bisa terjebak di cabang dalam tanpa solusi",
    "dfs_disadvantage_2": "Tidak menjamin shortest path",
    "dfs_disadvantage_3": "Stack overflow untuk graf sangat dalam",
    "dfs_visual_step_1": "ğŸ“Š Struktur Graf yang Sama",
    "dfs_visual_step_2": "ğŸ”„ DFS dari 0:",
    "dfs_visual_step_3": "0 â†’ 1 â†’ 3 (backtrack)",
    "dfs_visual_step_4": "1 â†’ 4 (backtrack) | 0 â†’ 2 (backtrack)",
    "dfs_visual_step_5": "âœ… Urutan Kunjungan: 0 â†’ 1 â†’ 3 â†’ 4 â†’ 2",
    "dfs_quiz_1_question": "Soal 1: Implementasikan DFS rekursif",
    "dfs_quiz_1_hint": "Tandai visited, print, rekursif ke semua tetangga yang belum visited.",
    "dfs_use_cases": "â€¢ Deteksi cycle di graf\nâ€¢ Topological sorting\nâ€¢ Penyelesaian Labirin (Maze)\nâ€¢ Puzzle solving (Sudoku, N-Queens)",
    "dfs_real_world": "Contoh: Menyelesaikan labirin\nDFS eksplorasi satu jalur sedalam mungkin, balik arah jika buntu.",
    "dijkstra_summary": "â€¢ Shortest path algorithm untuk weighted graph\nâ€¢ Menggunakan greedy approach dengan priority queue\nâ€¢ Tidak bisa handle negative weights\nâ€¢ Kompleksitas O((V + E) log V) dengan min-heap",
    "dijkstra_understanding": "Algoritma Dijkstra menemukan shortest path dari satu node ke semua node lain di weighted graph. Algoritma ini menggunakan greedy approach: selalu pilih node dengan jarak terpendek yang belum dikunjungi.",
    "dijkstra_step_1": "1. Set semua jarak ke infinity, start = 0",
    "dijkstra_step_2": "2. Tambahkan node start ke Priority Queue",
    "dijkstra_step_3": "3. Ambil node dengan jarak minimum dari queue",
    "dijkstra_step_4": "4. Relax tetangga: jika jalur baru lebih pendek, update jarak",
    "dijkstra_step_5": "5. Ulangi hingga queue kosong",
    "dijkstra_time_complexity": "â€¢ O((V + E) log V) dengan binary heap\nâ€¢ O(VÂ²) dengan array sederhana\nâ€¢ O(V + E) dengan Fibonacci heap",
    "dijkstra_space_complexity": "â€¢ O(V) - untuk jarak dan priority queue",
    "dijkstra_advantage_1": "Dijamin menemukan shortest path untuk bobot positif",
    "dijkstra_advantage_2": "Efisien untuk sparse graph",
    "dijkstra_advantage_3": "Dapat dioptimasi dengan berbagai heap",
    "dijkstra_advantage_4": "Banyak digunakan dan teruji dengan baik",
    "dijkstra_disadvantage_1": "Tidak bisa menangani bobot edge negatif",
    "dijkstra_disadvantage_2": "Lebih lambat dari BFS untuk unweighted graph",
    "dijkstra_disadvantage_3": "Membutuhkan priority queue yang efisien",
    "dijkstra_visual_step_1": "ğŸ“Š Graf Berbobot:",
    "dijkstra_visual_step_2": "Init: [0:0, 1:âˆ, 2:âˆ, 3:âˆ]",
    "dijkstra_visual_step_3": "Visit 0: [0:0, 1:4, 2:1, 3:âˆ]",
    "dijkstra_visual_step_4": "Visit 2: [0:0, 1:4, 2:1, 3:3]",
    "dijkstra_visual_step_5": "âœ… Jalur terpendek ditemukan!",
    "dijkstra_quiz_1_question": "Soal 1: Implementasikan Dijkstra sederhana",
    "dijkstra_quiz_1_hint": "Init jarak, loop V kali, pilih node min unvisited, relax edge-nya.",
    "dijkstra_use_cases": "â€¢ Navigasi GPS (Google Maps)\nâ€¢ Protokol routing jaringan\nâ€¢ Analisis jaringan sosial\nâ€¢ Pathfinding AI di game",
    "dijkstra_real_world": "Contoh: Google Maps mencari rute tercepat\nDijkstra dengan data kemacetan sebagai bobot.",
    "bellman_summary": "â€¢ Shortest path algorithm yang bisa handle negative weights\nâ€¢ Lebih lambat dari Dijkstra tapi lebih versatile\nâ€¢ Dapat mendeteksi negative cycles\nâ€¢ Kompleksitas O(VE)",
    "bellman_understanding": "Bellman-Ford adalah algoritma shortest path yang dapat menangani edge dengan weight negatif. Algoritma ini bekerja dengan relax semua edge sebanyak V-1 kali untuk menjamin shortest path ditemukan.",
    "bellman_step_1": "1. Inisialisasi jarak ke infinity, start = 0",
    "bellman_step_2": "2. Relax semua edge sebanyak V-1 kali",
    "bellman_step_3": "3. Cek negative cycle dengan satu pass tambahan",
    "bellman_step_4": "4. Jika jarak ter-update, berarti ada negative cycle",
    "bellman_time_complexity": "â€¢ O(VE) - V-1 iterasi, setiap cek semua E edge\nâ€¢ Lebih lambat dari Dijkstra O((V+E) log V)",
    "bellman_space_complexity": "â€¢ O(V) - untuk array jarak",
    "bellman_advantage_1": "Dapat menangani edge dengan bobot negatif",
    "bellman_advantage_2": "Dapat mendeteksi adanya negative cycle",
    "bellman_advantage_3": "Lebih simpel daripada Dijkstra",
    "bellman_advantage_4": "Cocok untuk sistem terdistribusi",
    "bellman_disadvantage_1": "Lebih lambat dengan kompleksitas O(VE)",
    "bellman_disadvantage_2": "Tidak efisien untuk graf yang sangat besar",
    "bellman_disadvantage_3": "Tidak bisa menangani negative cycle untuk shortest path",
    "bellman_visual_step_1": "ğŸ“ Iterasi 1: Relax semua edge",
    "bellman_visual_step_2": "ğŸ“ Iterasi 2: Relax lagi, jarak di-update",
    "bellman_visual_step_3": "ğŸ“ Iterasi 3: Tidak ada update lagi",
    "bellman_visual_step_4": "âœ… Selesai: Tidak ada negative cycle",
    "bellman_quiz_1_question": "Soal 1: Implementasikan Bellman-Ford",
    "bellman_quiz_1_hint": "Init jarak, loop V-1 kali, relax semua edge.",
    "bellman_use_cases": "â€¢ Routing jaringan dengan biaya negatif\nâ€¢ Deteksi arbitrase mata uang\nâ€¢ Sistem terdistribusi\nâ€¢ Ketika ada bobot negatif",
    "bellman_real_world": "Contoh: Deteksi arbitrase mata uang\nNegative cycle = peluang profit dari pertukaran mata uang.",
    "floyd_summary": "â€¢ Menemukan jalur terpendek antara semua pasangan node\nâ€¢ Algoritma dynamic programming\nâ€¢ Bekerja dengan bobot negatif (tanpa negative cycle)\nâ€¢ Kompleksitas O(VÂ³)",
    "floyd_understanding": "Algoritma Floyd-Warshall menemukan jarak terpendek antara setiap pasangan vertex dalam weighted graph. Ia bekerja dengan mempertimbangkan setiap node sebagai titik perantara antara semua pasangan lainnya.",
    "floyd_step_1": "1. Inisialisasi matriks jarak dengan bobot edge",
    "floyd_step_2": "2. Untuk setiap node perantara k:",
    "floyd_step_3": "3. Untuk setiap pasangan node (i, j):",
    "floyd_step_4": "4. Update dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])",
    "floyd_time_complexity": "â€¢ O(VÂ³) - triple nested loop\nâ€¢ Cocok untuk dense graph dengan V kecil",
    "floyd_space_complexity": "â€¢ O(VÂ²) - untuk matriks jarak",
    "floyd_advantage_1": "Menemukan jalur terpendek ALL-pairs sekaligus",
    "floyd_advantage_2": "Implementasi yang sederhana",
    "floyd_advantage_3": "Dapat menangani bobot edge negatif",
    "floyd_advantage_4": "Cocok untuk graf yang padat (dense)",
    "floyd_disadvantage_1": "Sangat lambat O(VÂ³)",
    "floyd_disadvantage_2": "Membutuhkan O(VÂ²) memori",
    "floyd_disadvantage_3": "Tidak efisien untuk graf jarang (sparse)",
    "floyd_disadvantage_4": "Tidak cocok untuk graf besar",
    "floyd_visual_step_1": "ğŸ“Š Graf dengan 4 node",
    "floyd_visual_step_2": "k=0: Update melalui node 0",
    "floyd_visual_step_3": "k=1: Update melalui node 1",
    "floyd_visual_step_4": "k=2: Update melalui node 2",
    "floyd_visual_step_5": "âœ… Semua jalur terpendek ditemukan!",
    "floyd_quiz_1_question": "Soal 1: Implementasikan Floyd-Warshall",
    "floyd_quiz_1_hint": "Triple nested loop: k (perantara), i (asal), j (tujuan).",
    "floyd_use_cases": "â€¢ Tabel routing jaringan\nâ€¢ Mencari transitive closure\nâ€¢ Mendeteksi negative cycles\nâ€¢ Graf padat berukuran kecil",
    "floyd_real_world": "Contoh: Tabel routing di router\nHitung jalur terpendek ke semua tujuan.",
    "kruskal_summary": "â€¢ Mencari Minimum Spanning Tree (MST) dari sebuah graf\nâ€¢ Menggunakan greedy approach dengan mengurutkan semua edge\nâ€¢ Menggunakan struktur data Union-Find untuk mencegah cycle\nâ€¢ Kompleksitas O(E log E) atau O(E log V)",
    "kruskal_understanding": "Algoritma Kruskal menemukan Minimum Spanning Tree dari graf terhubung dan tidak berarah. Algoritma ini mengurutkan semua edge berdasarkan bobot dan menambahkan edge terkecil yang tidak membentuk cycle.",
    "kruskal_step_1": "1. Urutkan semua edge dari bobot terkecil ke terbesar",
    "kruskal_step_2": "2. Pilih edge dengan bobot terkecil",
    "kruskal_step_3": "3. Jika edge tersebut tidak membentuk cycle, tambahkan ke MST",
    "kruskal_step_4": "4. Repeat until V-1 edges are added",
    "kruskal_time_complexity": "â€¢ O(E log E) - didominasi oleh sorting\nâ€¢ Menggunakan Union-Find yang optimal",
    "kruskal_space_complexity": "â€¢ O(V + E) - untuk Union-Find dan daftar edge",
    "kruskal_advantage_1": "Efisien untuk graf jarang (sparse)",
    "kruskal_advantage_2": "Sederhana dan mudah diimplementasikan",
    "kruskal_advantage_3": "Cocok untuk representasi edge-based",
    "kruskal_advantage_4": "Pendekatan greedy yang optimal",
    "kruskal_disadvantage_1": "Membutuhkan sorting O(E log E)",
    "kruskal_disadvantage_2": "Tidak efisien untuk graf padat (dense)",
    "kruskal_disadvantage_3": "Membutuhkan struktur data Union-Find",
    "kruskal_visual_step_1": "ğŸ“Š Graf dengan bobot",
    "kruskal_visual_step_2": "1. Urut: [1-2:1, 1-3:2, 0-2:3, 0-1:4, 2-3:4]",
    "kruskal_visual_step_3": "2. Tambah 1-2 (bobot 1) âœ“ | 3. Tambah 1-3 (bobot 2) âœ“",
    "kruskal_visual_step_4": "4. Tambah 0-2 (bobot 3) âœ“ | 5. Lewati 0-1 (cycle)",
    "kruskal_visual_step_5": "âœ… Berat MST: 6",
    "kruskal_quiz_1_question": "Soal 1: Implementasikan Kruskal",
    "kruskal_quiz_1_hint": "Sortir edge, gunakan Union-Find untuk cek cycle.",
    "kruskal_use_cases": "â€¢ Desain jaringan (minimalkan biaya kabel)\nâ€¢ Algoritma clustering\nâ€¢ Segmentasi gambar\nâ€¢ Algoritma aproksimasi",
    "kruskal_real_world": "Contoh: Desain jaringan kabel fiber optik\nHubungkan semua kota dengan biaya minimum.",
    "prim_summary": "â€¢ Mencari Minimum Spanning Tree (MST) mulai dari satu node awal\nâ€¢ Menggunakan greedy approach dengan priority queue (min-heap)\nâ€¢ Cocok untuk graf yang padat (dense)\nâ€¢ Kompleksitas O(E log V)",
    "prim_understanding": "Algoritma Prim menemukan MST dari graf dengan memulai dari satu node dan selalu menambahkan edge termurah yang menghubungkan node yang sudah dikunjungi dengan node yang belum dikunjungi.",
    "prim_step_1": "1. Pilih node awal secara acak",
    "prim_step_2": "2. Tambahkan semua edge yang terhubung ke Priority Queue",
    "prim_step_3": "3. Pilih edge dengan bobot min ke node yang belum dikunjungi",
    "prim_step_4": "4. Tandai node sebagai dikunjungi, ulangi hingga semua node terhubung",
    "prim_step_5": "5. Cari edge berbobot min berikutnya",
    "prim_step_6": "6. Ulangi hingga semua node terhubung",
    "prim_time_complexity": "â€¢ O(E log V) dengan binary heap\nâ€¢ O(E + V log V) dengan Fibonacci heap",
    "prim_space_complexity": "â€¢ O(V + E) - untuk graf dan priority queue",
    "prim_advantage_1": "Efisien untuk graf padat (dense)",
    "prim_advantage_2": "Cocok untuk representasi adjacency list",
    "prim_advantage_3": "Dapat dioptimasi dengan Fibonacci heap",
    "prim_advantage_4": "Lebih intuitif daripada Kruskal",
    "prim_disadvantage_1": "Membutuhkan priority queue",
    "prim_disadvantage_2": "Lebih kompleks daripada Kruskal",
    "prim_disadvantage_3": "Tidak efisien untuk graf jarang (sparse)",
    "prim_visual_step_1": "ğŸ“Š Struktur Graf yang Sama",
    "prim_visual_step_2": "1. Mulai: visited={0}",
    "prim_visual_step_3": "2. Tambah 0-2 (bobot 3), visited={0,2}",
    "prim_visual_step_4": "3. Tambah 2-1 (bobot 1), visited={0,2,1}",
    "prim_visual_step_5": "âœ… Berat MST: 6",
    "prim_quiz_1_question": "Soal 1: Implementasikan Prim sederhana",
    "prim_quiz_1_hint": "Gunakan priority queue, set visited, tambahkan edge bobot minimum.",
    "prim_use_cases": "â€¢ Desain jaringan\nâ€¢ Clustering\nâ€¢ Algoritma aproksimasi\nâ€¢ Graf padat (dense graphs)",
    "prim_real_world": "Contoh: Desain jaringan listrik\nHubungkan semua rumah dengan perkabelan minimum.",
    "caesar_summary": "â€¢ Cipher substitusi paling sederhana\nâ€¢ Menggeser setiap huruf sebanyak n posisi\nâ€¢ Mudah dipecahkan dengan brute force\nâ€¢ Kompleksitas O(n) untuk enkripsi/dekripsi",
    "caesar_understanding": "Caesar Cipher adalah teknik enkripsi klasik yang menggeser setiap huruf dalam plaintext sebanyak posisi tertentu dalam alfabet. Misalnya dengan shift 3, 'A' menjadi 'D', 'B' menjadi 'E', dst.",
    "caesar_step_1": "1. Tentukan nilai shift (kunci)",
    "caesar_step_2": "2. Untuk setiap karakter: jika huruf, geser",
    "caesar_step_3": "3. Wrap around jika melewati Z (A menjadi D dengan shift 3)",
    "caesar_step_4": "4. Untuk dekripsi, geser ke arah sebaliknya",
    "caesar_time_complexity": "â€¢ O(n) dimana n = panjang teks\nâ€¢ Setiap karakter diproses sekali",
    "caesar_space_complexity": "â€¢ O(n) - untuk string hasil",
    "caesar_advantage_1": "Sangat sederhana dan mudah dipahami",
    "caesar_advantage_2": "Cepat untuk enkripsi/dekripsi",
    "caesar_advantage_3": "Tidak membutuhkan komputasi kompleks",
    "caesar_advantage_4": "Cocok untuk pembelajaran kriptografi",
    "caesar_disadvantage_1": "Sangat tidak aman (hanya 26 kemungkinan kunci)",
    "caesar_disadvantage_2": "Mudah dipecahkan dengan brute force",
    "caesar_disadvantage_3": "Mudah dipecahkan dengan frequency analysis",
    "caesar_disadvantage_4": "Tidak cocok untuk data sensitif",
    "caesar_visual_step_1": "ğŸ“ Plaintext: HELLO",
    "caesar_visual_step_2": "ğŸ”‘ Shift: 3",
    "caesar_visual_step_3": "ğŸ”„ Enkripsi:",
    "caesar_visual_step_4": "H (7) + 3 = K (10) | E (4) + 3 = H (7)",
    "caesar_visual_step_5": "L (11) + 3 = O (14) | L (11) + 3 = O (14)",
    "caesar_visual_step_6": "O (14) + 3 = R (17)",
    "caesar_visual_step_7": "ğŸ”’ Ciphertext: KHOOR",
    "caesar_quiz_1_question": "Soal 1: Implementasikan enkripsi Caesar",
    "caesar_quiz_1_hint": "Loop setiap char, cek huruf, geser dengan modulo 26.",
    "caesar_quiz_2_question": "Soal 2: Implementasikan dekripsi",
    "caesar_quiz_2_hint": "Dekripsi = enkripsi dengan shift (26 - shift).",
    "caesar_use_cases": "â€¢ Pembelajaran kriptografi dasar\nâ€¢ ROT13 (shift 13) untuk obfuscation\nâ€¢ Puzzle dan game\nâ€¢ Demonstrasi konsep",
    "caesar_real_world": "Contoh: ROT13 di forum internet\nMenyembunyikan spoiler atau jawaban teka-teki.",
    "vigenere_summary": "â€¢ Polyalphabetic substitution cipher\nâ€¢ Menggunakan keyword untuk multiple shifts\nâ€¢ Lebih aman dari Caesar Cipher\nâ€¢ Kompleksitas O(n)",
    "vigenere_understanding": "Vigenere Cipher adalah pengembangan dari Caesar Cipher yang menggunakan keyword untuk menentukan shift yang berbeda untuk setiap huruf. Ini membuatnya lebih sulit dipecahkan dengan frequency analysis.",
    "vigenere_step_1": "1. Tentukan keyword (kata kunci)",
    "vigenere_step_2": "2. Ulangi keyword hingga sepanjang plaintext",
    "vigenere_step_3": "3. Untuk setiap huruf: ambil shift dari posisi huruf key",
    "vigenere_step_4": "4. Terapkan Caesar shift dengan nilai tersebut",
    "vigenere_step_5": "5. Untuk dekripsi, kurangi dengan nilai shift",
    "vigenere_step_6": "6. String hasil adalah ciphertext",
    "vigenere_time_complexity": "â€¢ O(n) dimana n = panjang teks",
    "vigenere_space_complexity": "â€¢ O(n) - untuk string hasil",
    "vigenere_advantage_1": "Lebih aman daripada Caesar Cipher",
    "vigenere_advantage_2": "Tahan terhadap frequency analysis sederhana",
    "vigenere_advantage_3": "Mudah diimplementasikan",
    "vigenere_advantage_4": "Keyword bisa panjang mana saja",
    "vigenere_disadvantage_1": "Masih bisa dipecahkan dengan Kasiski examination",
    "vigenere_disadvantage_2": "Rentan jika keyword pendek",
    "vigenere_disadvantage_3": "Tidak aman untuk standar modern",
    "vigenere_disadvantage_4": "Memerlukan manajemen kunci",
    "vigenere_visual_step_1": "ğŸ“ Plaintext: HELLO",
    "vigenere_visual_step_2": "ğŸ”‘ Key: KEY (K=10, E=4, Y=24)",
    "vigenere_visual_step_3": "ğŸ”„ Enkripsi:",
    "vigenere_visual_step_4": "H+K=R, E+E=I, L+Y=J, L+K=V, O+E=S",
    "vigenere_visual_step_5": "ğŸ”’ Ciphertext: RIJVS",
    "vigenere_visual_step_6": "âœ… Selesai!",
    "vigenere_quiz_1_question": "Soal 1: Implementasikan enkripsi Vigenere",
    "vigenere_quiz_1_hint": "Loop teks, ambil shift dari key dengan modulo, enkripsi.",
    "vigenere_use_cases": "â€¢ Pembelajaran kriptografi\nâ€¢ Enkripsi sederhana data non-kritis\nâ€¢ Demonstrasi polyalphabetic cipher\nâ€¢ Studi sejarah kriptografi",
    "vigenere_real_world": "Contoh: Digunakan Konfederasi di Perang Saudara Amerika\nUntuk enkripsi pesan militer.",
    "rsa_summary": "â€¢ Public-key cryptography algorithm\nâ€¢ Menggunakan dua kunci: public dan private\nâ€¢ Berbasis matematika modular dan bilangan prima\nâ€¢ Kompleksitas enkripsi O(log n), dekripsi O(log n)",
    "rsa_understanding": "RSA adalah algoritma kriptografi asimetris yang menggunakan sepasang kunci: public key untuk enkripsi dan private key untuk dekripsi. Keamanannya bergantung pada sulitnya memfaktorkan bilangan besar.",
    "rsa_step_1": "1. Pilih dua bilangan prima besar p dan q",
    "rsa_step_2": "2. Hitung n = p * q",
    "rsa_step_3": "3. Hitung phi = (p-1) * (q-1)",
    "rsa_step_4": "4. Pilih e sedemikian hingga 1 < e < phi dan coprime dengan phi",
    "rsa_step_5": "5. Hitung d (invers muliplikatif e mod phi)",
    "rsa_step_6": "6. Kunci Publik: (e, n), Kunci Privat: (d, n)",
    "rsa_step_7": "7. Enkripsi: c = m^e mod n",
    "rsa_step_8": "8. Dekripsi: m = c^d mod n",
    "rsa_time_complexity": "â€¢ Key gen: O(kÂ³), Enkripsi/Dekripsi: O(log n)",
    "rsa_space_complexity": "â€¢ O(k) untuk menyimpan kunci",
    "rsa_advantage_1": "Public-key (tidak perlu berbagi kunci rahasia)",
    "rsa_advantage_2": "Dapat digunakan untuk tanda tangan digital",
    "rsa_advantage_3": "Banyak digunakan dan teruji dengan baik",
    "rsa_advantage_4": "Keamanan berbasis problem matematika sulit",
    "rsa_disadvantage_1": "Lebih lambat dari enkripsi simetris",
    "rsa_disadvantage_2": "Butuh ukuran kunci besar (2048+ bit)",
    "rsa_disadvantage_3": "Rentan terhadap komputasi kuantum",
    "rsa_disadvantage_4": "Kompleks untuk diimplementasikan dengan benar",
    "rsa_visual_step_1": "ğŸ”‘ Key Gen: p=61, q=53 â†’ n=3233, Ï†=3120",
    "rsa_visual_step_2": "ğŸ”‘ e=17, d=2753",
    "rsa_visual_step_3": "ğŸ”’ Enkripsi m=123:",
    "rsa_visual_step_4": "c = 123^17 mod 3233 = 855",
    "rsa_visual_step_5": "ğŸ”“ Dekripsi c=855:",
    "rsa_visual_step_6": "m = 855^2753 mod 3233 = 123",
    "rsa_quiz_1_question": "Soal 1: Implementasikan eksponensial modular",
    "rsa_quiz_1_hint": "Gunakan metode square-and-multiply dengan modulo.",
    "rsa_use_cases": "â€¢ HTTPS/SSL/TLS\nâ€¢ Tanda tangan digital\nâ€¢ Email aman (PGP)\nâ€¢ Cryptocurrency",
    "rsa_real_world": "Contoh: HTTPS di browser\nRSA untuk pertukaran kunci, lalu simetris untuk data.",
    "aes_summary": "â€¢ Advanced Encryption Standard\nâ€¢ Symmetric block cipher\nâ€¢ Menggunakan substitution-permutation network\nâ€¢ Key sizes: 128, 192, atau 256 bits",
    "aes_understanding": "AES adalah standar enkripsi simetris modern yang sangat aman dan efisien. Menggunakan operasi substitusi dan permutasi berulang kali pada blok data 128-bit.",
    "aes_step_1": "1. Key Expansion: Buat round keys",
    "aes_step_2": "2. Initial Round: AddRoundKey",
    "aes_step_3": "3. Main Rounds: SubBytes, ShiftRows, MixColumns, AddRoundKey",
    "aes_step_4": "4. Final Round: SubBytes, ShiftRows, AddRoundKey",
    "aes_time_complexity": "â€¢ O(1) untuk enkripsi/dekripsi blok\nâ€¢ Jumlah ronde tetap",
    "aes_space_complexity": "â€¢ O(1) - operasi in-place",
    "aes_advantage_1": "Sangat aman (standar Pemerintah AS)",
    "aes_advantage_2": "Cepat dan efisien",
    "aes_advantage_3": "Akselerasi hardware tersedia",
    "aes_advantage_4": "Didukung luas secara global",
    "aes_disadvantage_1": "Simetris (butuh berbagi kunci rahasia)",
    "aes_disadvantage_2": "Kompleks untuk diimplementasikan manual",
    "aes_disadvantage_3": "Block cipher (butuh mode operasi)",
    "aes_disadvantage_4": "Rentan serangan side-channel jika tidak hati-hati",
    "aes_visual_step_1": "ğŸ“Š Proses Enkripsi AES-128:",
    "aes_visual_step_2": "ğŸ”‘ Input: blok 128-bit & kunci",
    "aes_visual_step_3": "ğŸ”„ Ronde 1-10 Operasi",
    "aes_visual_step_4": "1. SubBytes (S-box)",
    "aes_visual_step_5": "2. ShiftRows | 3. MixColumns | 4. AddRoundKey",
    "aes_visual_step_6": "ğŸ”’ Output: ciphertext 128-bit",
    "aes_quiz_1_question": "Soal 1: Implementasikan AddRoundKey (XOR)",
    "aes_quiz_1_hint": "Loop dan XOR setiap byte state dengan round key.",
    "aes_use_cases": "â€¢ Enkripsi file\nâ€¢ Enkripsi disk (BitLocker)\nâ€¢ VPN (IPsec, WireGuard)\nâ€¢ Keamanan nirkabel (WPA3)",
    "aes_real_world": "Contoh: WhatsApp end-to-end encryption\nMenggunakan AES-256 untuk enkripsi pesan.",
    "sha256_summary": "â€¢ Fungsi hash kriptografi satu arah\nâ€¢ Menghasilkan output tetap 256-bit (32-byte)\nâ€¢ Probabilitas tabrakan sangat rendah\nâ€¢ Digunakan untuk integritas data dan blockchain",
    "sha256_understanding": "SHA-256 (Secure Hash Algorithm 256-bit) adalah algoritma hashing yang menerima input ukuran apa pun dan menghasilkan string 256-bit yang unik. Ini bersifat deterministik dan satu arah.",
    "sha256_step_1": "1. Padding: tambahkan bit hingga 448 (mod 512)",
    "sha256_step_2": "2. Tambahkan panjang: panjang pesan asli",
    "sha256_step_3": "3. Inisialisasi: 8 konstanta hash",
    "sha256_step_4": "4. Proses: 64 ronde fungsi kompresi",
    "sha256_step_5": "5. Finalisasi: gabungkan nilai hash",
    "sha256_time_complexity": "â€¢ O(n) dimana n = panjang pesan",
    "sha256_space_complexity": "â€¢ O(1) - membutuhkan ruang konstan",
    "sha256_advantage_1": "Sangat aman dan tahan tabrakan",
    "sha256_advantage_2": "Deterministik dan efisien",
    "sha256_advantage_3": "Properti satu arah",
    "sha256_advantage_4": "Tidak butuh kunci",
    "sha256_advantage_5": "Standar global",
    "sha256_disadvantage_1": "Rentan serangan length extension",
    "sha256_disadvantage_2": "Rentan rainbow table jika tidak di-salt",
    "sha256_disadvantage_3": "Bukan enkripsi (tidak bisa dibalik)",
    "sha256_visual_step_1": "ğŸ“ Input: \"hello\"",
    "sha256_visual_step_2": "ğŸ”„ Proses Blok (512-bit)",
    "sha256_visual_step_3": "ğŸ”„ 64 Ronde Kompresi",
    "sha256_visual_step_4": "ğŸ”’ Hash: 2cf24dba...938b9824",
    "sha256_quiz_1_question": "Soal 1: Implementasikan rotasi kanan (ROTR)",
    "sha256_quiz_1_hint": "Implementasikan 32-bit right rotate menggunakan shift bitwise dan OR.",
    "sha256_use_cases": "â€¢ Tanda tangan digital\nâ€¢ Blockchain (Bitcoin)\nâ€¢ Hashing password (dengan salt)\nâ€¢ Verifikasi integritas file",
    "sha256_real_world": "Contoh: Menambang Bitcoin\nSHA-256 digunakan untuk hash header blok.",
    "notification_login_success": "Login berhasil! Selamat datang ğŸ‰",
    "notification_login_quick_success": "Login cepat berhasil! ğŸš€",
    "notification_login_cancelled": "Login dibatalkan",
    "notification_login_failed": "Login gagal: {error}",
    "notification_logout_success": "Berhasil keluar. Sampai jumpa lagi! ğŸ‘‹",
    "notification_logout_failed": "Logout gagal: {error}",
    "security_status_title": "Akun Anda Aman",
    "security_status_subtitle": "Semua pengaturan keamanan Anda terlihat baik.",
    "security_login_recovery": "Login & Pemulihan",
    "security_change_password": "Ubah Kata Sandi",
    "security_change_password_subtitle": "Perbarui kredensial login Anda",
    "security_session_info": "Info Sesi",
    "security_session_info_subtitle": "Perangkat saat ini teridentifikasi",
    "security_session_secured_msg": "Sesi aman di perangkat ini",
    "security_advanced": "Keamanan Lanjutan",
    "security_2fa": "Autentikasi Dua Faktor",
    "security_2fa_subtitle": "Memerlukan verifikasi email",
    "security_biometric": "Login Biometrik",
    "security_biometric_subtitle": "Face ID atau Sidik Jari",
    "security_danger_zone": "Zona Bahaya",
    "security_delete_account": "Hapus Akun",
    "security_delete_account_subtitle": "Hapus permanen semua data Anda",
    "security_setting_updated": "Pengaturan keamanan diperbarui",
    "security_auth_failed": "Autentikasi gagal",
    "security_password_not_available": "Ubah kata sandi tidak tersedia untuk tipe akun ini",
    "security_change_password_diag_title": "Ubah Kata Sandi",
    "security_change_password_diag_msg": "Masukkan kata sandi keamanan baru Anda di bawah ini",
    "security_password_min_chars": "Minimal 6 karakter",
    "security_update": "PERBARUI",
    "security_cancel": "BATAL",
    "security_password_too_short": "Kata sandi terlalu pendek",
    "security_password_updated": "Kata sandi berhasil diperbarui",
    "security_error": "Error: {error}",
    "security_delete_account_diag_title": "Hapus Akun?",
    "security_delete_account_diag_msg": "Tindakan ini PERMANEN. Semua progres, XP, dan lencana Anda akan hilang selamanya.",
    "security_delete": "HAPUS",
    "security_keep_account": "TETAPKAN AKUN",
    "security_account_deleted": "Akun berhasil dihapus selamanya",
    "security_delete_failed": "Gagal menghapus: {error}"
}