{
  "home_title": "Algo Lab Pro",
  "home_subtitle": "Master Algorithms with Real-World Data Visualization",
  "learning_title": "Learn Algorithms",
  "learning_subtitle": "Explore and practice algorithm concepts.",
  "search_hint": "Search for algorithm or category",
  "category_all": "All",
  "category_sorting": "Sorting",
  "category_graph": "Graph",
  "category_search": "Search",
  "category_cryptography": "Cryptography",
  "category_tree": "Tree",
  "popular_modules": "Popular Modules",
  "sorting_algorithms": "Sorting Algorithms",
  "graph_algorithms": "Graph Algorithms",
  "search_algorithms": "Search Algorithms",
  "cryptography": "Cryptography",
  "bubble_title": "Bubble View",
  "visualization_bubble": "Visualization Bubble Sort",
  "comparisons": "Comparisons",
  "swaps": "Swaps",
  "time": "Time",
  "controls": "Controls",
  "start": "Start",
  "pause": "Pause",
  "restart": "Restart",
  "shuffle": "Shuffle",
  "animation_speed": "Animation Speed",
  "bubble_sort_title": "Bubble Sort",
  "bubble_sort_desc": "Comparison-based simple sorting algorithm.",
  "quick_sort_title": "Quick Sort",
  "quick_sort_desc": "Divide-and-conquer sorting using pivot.",
  "merge_sort_title": "Merge Sort",
  "merge_sort_desc": "Divide-and-conquer sorting using merging.",
  "insertion_sort_title": "Insertion Sort",
  "insertion_sort_desc": "Sorting by inserting elements in order.",
  "selection_sort_title": "Selection Sort",
  "selection_sort_desc": "Sorting by selecting the minimum element.",
  "heap_sort_title": "Heap Sort",
  "heap_sort_desc": "Sorting using heap data structure.",
  "dijkstra_title": "Dijkstra Algorithm",
  "dijkstra_desc": "Shortest path using greedy strategy.",
  "bfs_title": "Breadth-First Search (BFS)",
  "bfs_desc": "Graph traversal using queue.",
  "dfs_title": "Depth-First Search (DFS)",
  "dfs_desc": "Graph traversal using stack/recursion.",
  "bellman_ford_title": "Bellman-Ford Algorithm",
  "bellman_ford_desc": "Shortest path with negative edge support.",
  "floyd_warshall_title": "Floyd-Warshall Algorithm",
  "floyd_warshall_desc": "All-pairs shortest path.",
  "kruskal_title": "Kruskal Minimum Spanning Tree",
  "kruskal_desc": "MST using union‚Äìfind.",
  "prim_title": "Prim Minimum Spanning Tree",
  "prim_desc": "MST using priority queue.",
  "linear_search_title": "Linear Search",
  "linear_search_desc": "Sequential search one-by-one.",
  "binary_search_title": "Binary Search",
  "binary_search_desc": "Fast search using divide-by-two.",
  "interpolation_search_title": "Interpolation Search",
  "interpolation_search_desc": "Improved binary search for uniform data.",
  "caesar_cipher_title": "Caesar Cipher",
  "caesar_cipher_desc": "Classic shifting-based encryption.",
  "vigenere_cipher_title": "Vigenere Cipher",
  "vigenere_cipher_desc": "Polyalphabetic key-based encryption.",
  "rsa_title": "RSA",
  "rsa_desc": "Modern cryptography using large primes.",
  "aes_title": "AES",
  "aes_desc": "Advanced Encryption Standard.",
  "sha256_title": "SHA-256 Hashing",
  "sha256_desc": "One-way hashing algorithm.",
  "rsa_title_pro": "RSA Encryption",
  "rsa_desc_pro": "Digital Transaction Security (E-Bank)",
  "astar_title_pro": "A* Pathfinding Pro",
  "astar_desc_pro": "Autonomous Drone Routing (Smart City)",
  "astar_title": "A* Pathfinding",
  "astar_desc": "Route finding algorithm.",
  "learning_summary": "Summary",
  "learning_introduction": "Introduction",
  "learning_understanding": "Understanding Bubble Sort",
  "learning_how_it_works": "How It Works",
  "learning_algorithm_steps": "Algorithm Steps",
  "learning_complexity": "Time & Space Complexity",
  "learning_case_study": "Real-World Case Study",
  "learning_step_by_step": "Step-by-Step Visualization",
  "learning_code_implementation": "Code Implementation (Dart)",
  "learning_output": "Output",
  "learning_run_code": "Run Code",
  "learning_concept": "Concept Understanding",
  "learning_pros_cons": "Advantages & Disadvantages",
  "learning_quiz": "Quiz & Coding Practice",
  "learning_progress": "Learning Progress",
  "learning_completed_msg": "Completed! All quizzes finished",
  "learning_time_complexity": "‚è±Ô∏è Time Complexity",
  "learning_space_complexity": "üíæ Space Complexity",
  "learning_real_world": "Real-World Example",
  "quiz_label": "Quiz",
  "learning_use_cases": "Use Cases",
  "learning_advantages": "Advantages",
  "learning_disadvantages": "Disadvantages",
  "learning_when_to_use": "When to Use",
  "bubble_summary_text": "‚Ä¢ Simple comparison-based sorting algorithm\n‚Ä¢ Builds final sorted array by swapping elements\n‚Ä¢ Not efficient for large datasets",
  "bubble_understanding_text": "Understanding Bubble Sort helps you understand how the algorithm works & the steps used to implement bubble sort.",
  "bubble_step_1": "1. Comparison-based sorting algorithm",
  "bubble_step_2": "2. Repeatedly swaps adjacent elements if out of order",
  "bubble_step_3": "3. Continues until no more swaps are needed",
  "bubble_step_4": "4. Largest element \"bubbles\" to the end each pass",
  "bubble_step_5": "5. Continue until the end of array",
  "bubble_step_6": "6. Repeat the process for n-1 passes",
  "bubble_step_7": "7. Stop when no swaps occur in a complete pass",
  "onboarding_step_1_header": "STEP 1 OF 3",
  "onboarding_step_1_title": "Watch Algorithms\nIn Action",
  "onboarding_step_1_body": "Understand complex logic through interactive visualization.\nSee how data is sorted and processed in realtime on your screen.",
  "onboarding_step_2_header": "STEP 2 OF 3",
  "onboarding_step_2_title": "Master Algorithms\nWith Case Studies",
  "onboarding_step_2_subtitle": "Learn practically with real examples. Run code, see results, and understand deeply how it works.",
  "onboarding_step_3_header": "READY TO START",
  "onboarding_step_3_title": "Ready to Launch\ninto Algo Lab?",
  "onboarding_step_3_body": "Master algorithms, solve challenges, and build your coding future.",
  "common_next": "Next",
  "common_login_google": "Continue with Google",
  "common_login": "Sign in faster",
  "common_recommended": "Recommended",
  "common_skip": "Skip",
  "common_error_prefix": "Error: ",
  "learning_content_unavailable": "Content unavailable",
  "learning_reset_progress_title": "Reset Progress?",
  "learning_reset_progress_content": "All progress and quiz answers will be deleted.",
  "common_cancel": "Cancel",
  "common_reset": "Reset",
  "learning_reset_progress_tooltip": "Reset Progress",
  "learning_unlock_quiz_msg": "Run code above to unlock quiz.",
  "learning_hint_prefix": "Hint: ",
  "common_submit": "Submit",
  "common_debug_console": "DEBUG CONSOLE",
  "common_solution_file": "solution.dart",
  "bubble_time_complexity": "‚Ä¢ Best Case: O(n) - already sorted\n‚Ä¢ Average Case: O(n¬≤) - random array\n‚Ä¢ Worst Case: O(n¬≤) - reverse sorted",
  "bubble_space_complexity": "‚Ä¢ O(1) - only requires temporary variables\n‚Ä¢ In-place sorting (no extra array needed)",
  "bubble_advantage_1": "Very easy to understand and implement",
  "bubble_advantage_2": "Does not require extra memory (in-place)",
  "bubble_advantage_3": "Stable - maintains order of equal elements",
  "bubble_advantage_4": "Can detect if array is already sorted",
  "bubble_advantage_5": "Suitable for very small datasets",
  "bubble_disadvantage_1": "Very slow for large datasets O(n¬≤)",
  "bubble_disadvantage_2": "Inefficient compared to modern algorithms",
  "bubble_disadvantage_3": "Many comparison and swap operations",
  "bubble_disadvantage_4": "Not suitable for production applications",
  "bubble_disadvantage_5": "Poor performance even for medium data",
  "bubble_visual_step_1": "üìä Initial Array: [64, 34, 25, 12, 22]",
  "bubble_visual_step_2": "üîÑ Pass 1: Compare adjacent pairs",
  "bubble_visual_step_3": "   64 > 34 ‚Üí Swap ‚Üí [34, 64, 25, 12, 22]",
  "bubble_visual_step_4": "   64 > 25 ‚Üí Swap ‚Üí [34, 25, 64, 12, 22]",
  "bubble_visual_step_5": "   64 > 12 ‚Üí Swap ‚Üí [34, 25, 12, 64, 22]",
  "bubble_visual_step_6": "   64 > 22 ‚Üí Swap ‚Üí [34, 25, 12, 22, 64] ‚úì",
  "bubble_visual_step_7": "üîÑ Pass 2: Largest element is at the end",
  "bubble_visual_step_8": "   34 > 25 ‚Üí Swap ‚Üí [25, 34, 12, 22, 64]",
  "bubble_visual_step_9": "   34 > 12 ‚Üí Swap ‚Üí [25, 12, 34, 22, 64]",
  "bubble_visual_step_10": "   34 > 22 ‚Üí Swap ‚Üí [25, 12, 22, 34, 64] ‚úì",
  "bubble_visual_step_11": "üîÑ Pass 3-4: Process continues...",
  "bubble_visual_step_12": "‚úÖ Final Result: [12, 22, 25, 34, 64]",
  "bubble_use_cases": "‚Ä¢ Learning sorting algorithms\n‚Ä¢ Very small datasets (< 10 elements)\n‚Ä¢ Nearly sorted (with optimization)\n‚Ä¢ Sorting concept demonstration",
  "bubble_real_world": "Example: Sorting 5 student exam scores\nInput: [85, 72, 90, 68, 95]\nOutput: [68, 72, 85, 90, 95]",
  "bubble_quiz_1_question": "Question 1: Implement basic bubbleSort function",
  "bubble_quiz_1_hint": "Use nested loops. Outer loop for passes, inner loop for comparisons.",
  "bubble_quiz_2_question": "Question 2: Add early termination optimization",
  "bubble_quiz_2_hint": "Use a boolean flag \"swapped\". If no swap occurs, break!",
  "bubble_quiz_3_question": "Question 3: Modify for descending order",
  "bubble_quiz_3_hint": "Change operator from > to < for descending",
  "quick_summary": "‚Ä¢ Highly efficient divide-and-conquer algorithm\n‚Ä¢ Picks a pivot and divides array into two parts\n‚Ä¢ Smaller elements left, larger right of pivot\n‚Ä¢ One of the fastest sorting algorithms in practice",
  "quick_understanding": "Quick Sort is a sorting algorithm that uses a divide-and-conquer strategy. It selects an element as a \"pivot\" and partitions the array so that all elements smaller than the pivot are on the left, and larger ones on the right. This process is recursive.",
  "quick_step_1": "1. Choose pivot (usually last element)",
  "quick_step_2": "2. Partition array: elements < pivot left, > pivot right",
  "quick_step_3": "3. Place pivot in correct position",
  "quick_step_4": "4. Recursively sort left part",
  "quick_step_5": "5. Recursively sort right part",
  "quick_step_6": "6. Base case: array with 0 or 1 element is sorted",
  "quick_time_complexity": "‚Ä¢ Best Case: O(n log n)\n‚Ä¢ Average Case: O(n log n)\n‚Ä¢ Worst Case: O(n¬≤)",
  "quick_space_complexity": "‚Ä¢ O(log n) - for recursion stack",
  "quick_advantage_1": "Very fast in practice",
  "quick_advantage_2": "In-place sorting",
  "quick_advantage_3": "Cache-friendly",
  "quick_advantage_4": "Easily parallelized",
  "quick_disadvantage_1": "Not stable",
  "quick_disadvantage_2": "Worst case O(n¬≤)",
  "quick_disadvantage_3": "Recursive (stack overflow risk)",
  "quick_visual_step_1": "üìä Array: [64, 34, 25, 12, 22]",
  "quick_visual_step_2": "üéØ Pivot: 22",
  "quick_visual_step_3": "üìç Partition: [12] | 22 | [64,34,25]",
  "quick_visual_step_4": "üîÑ Recursive...",
  "quick_visual_step_5": "‚úÖ Result: [12, 22, 25, 34, 64]",
  "quick_quiz_1_question": "Implement partition",
  "quick_quiz_1_hint": "Use pivot, iteration and swap",
  "quick_use_cases": "‚Ä¢ Sorting large datasets\n‚Ä¢ Operating systems\n‚Ä¢ Database optimization",
  "quick_real_world": "Quick Sort: ~20ms for 1M records\nBubble Sort: ~30 seconds",
  "merge_summary": "‚Ä¢ Stable divide-and-conquer algorithm\n‚Ä¢ Divides array into two halves until size 1\n‚Ä¢ Merges back in correct order\n‚Ä¢ Consistent O(n log n) for all cases",
  "merge_understanding": "Merge Sort divides the array into two halves, recursively sorts each half, then merges the two sorted halves.",
  "merge_step_1": "1. Divide array into two halves",
  "merge_step_2": "2. Recursively sort left part",
  "merge_step_3": "3. Recursively sort right part",
  "merge_step_4": "4. Merge the two parts",
  "merge_time_complexity": "‚Ä¢ Best/Avg/Worst: O(n log n) - CONSISTENT!",
  "merge_space_complexity": "‚Ä¢ O(n) - requires temporary array",
  "merge_advantage_1": "Consistent O(n log n)",
  "merge_advantage_2": "Stable",
  "merge_advantage_3": "Predictable performance",
  "merge_disadvantage_1": "Requires O(n) extra space",
  "merge_disadvantage_2": "Not in-place",
  "merge_visual_step_1": "üìä Array: [64, 34, 25, 12, 22]",
  "merge_visual_step_2": "‚úÇÔ∏è Split: [64,34,25] [12,22]",
  "merge_visual_step_3": "üîÄ Merge: [12,22,25,34,64]",
  "merge_quiz_1_question": "Implement merge",
  "merge_quiz_1_hint": "Create 2 temp arrays, compare and merge",
  "merge_use_cases": "‚Ä¢ Sorting linked list\n‚Ä¢ External sorting\n‚Ä¢ Stable sorting requirement",
  "merge_real_world": "Sorting 1GB file: Split into chunks, sort, merge",
  "insertion_summary": "‚Ä¢ Builds sorted array one element at a time\n‚Ä¢ Inserts each element into correct position\n‚Ä¢ Efficient for small or nearly sorted arrays\n‚Ä¢ Stable sorting algorithm",
  "insertion_understanding": "Insertion Sort works like sorting cards in your hand. We pick one card at a time and insert it into the correct position among the already sorted cards.",
  "insertion_step_1": "1. Start from second element (index 1)",
  "insertion_step_2": "2. Save current element as \"key\"",
  "insertion_step_3": "3. Compare key with previous elements",
  "insertion_step_4": "4. Shift larger elements to the right",
  "insertion_step_5": "5. Insert key into correct position",
  "insertion_step_6": "6. Repeat for all elements",
  "insertion_time_complexity": "‚Ä¢ Best Case: O(n) - already sorted\n‚Ä¢ Average Case: O(n¬≤)\n‚Ä¢ Worst Case: O(n¬≤) - reverse sorted",
  "insertion_space_complexity": "‚Ä¢ O(1) - in-place sorting",
  "insertion_advantage_1": "Simple and easy to implement",
  "insertion_advantage_2": "Efficient for small arrays (n < 50)",
  "insertion_advantage_3": "Efficient for nearly sorted arrays",
  "insertion_advantage_4": "Stable and in-place",
  "insertion_advantage_5": "Online algorithm (can sort data as it arrives)",
  "insertion_disadvantage_1": "O(n¬≤) for large datasets",
  "insertion_disadvantage_2": "Inefficient for large random arrays",
  "insertion_disadvantage_3": "Many shift operations",
  "insertion_visual_step_1": "üìä Array: [12, 11, 13, 5, 6]",
  "insertion_visual_step_2": "üéØ Key=11: [11, 12, 13, 5, 6]",
  "insertion_visual_step_3": "üéØ Key=13: [11, 12, 13, 5, 6] (Already correct)",
  "insertion_visual_step_4": "üéØ Key=5: Shift 13,12,11 ‚Üí [5, 11, 12, 13, 6]",
  "insertion_visual_step_5": "üéØ Key=6: Shift 13,12,11 ‚Üí [5, 6, 11, 12, 13]",
  "insertion_visual_step_6": "‚úÖ Done!",
  "insertion_quiz_1_question": "Question 1: Implement Insertion Sort",
  "insertion_quiz_1_hint": "Loop from index 1, save key, shift elements > key to right",
  "insertion_use_cases": "‚Ä¢ Small arrays (< 50 elements)\n‚Ä¢ Nearly sorted arrays\n‚Ä¢ Online sorting (data streaming)\n‚Ä¢ Hybrid sorting (with Quick/Merge Sort)",
  "insertion_real_world": "Example: Sorting playing cards in hand\nPick cards one by one and insert in correct position",
  "selection_summary": "‚Ä¢ Finds minimum element and swaps with first element\n‚Ä¢ Repeat for remaining array\n‚Ä¢ Simple but inefficient for large datasets\n‚Ä¢ Performs minimal swaps (n-1 swaps)",
  "selection_understanding": "Selection Sort works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first element of that part.",
  "selection_step_1": "1. Find minimum element in array",
  "selection_step_2": "2. Swap with first element",
  "selection_step_3": "3. Find minimum in remaining array (start index 1)",
  "selection_step_4": "4. Swap with second element",
  "selection_step_5": "5. Repeat until array is sorted",
  "selection_time_complexity": "‚Ä¢ Best Case: O(n¬≤)\n‚Ä¢ Average Case: O(n¬≤)\n‚Ä¢ Worst Case: O(n¬≤) - ALWAYS O(n¬≤)!",
  "selection_space_complexity": "‚Ä¢ O(1) - in-place sorting",
  "selection_advantage_1": "Simple and easy to understand",
  "selection_advantage_2": "Minimal swap operations (n-1 swaps)",
  "selection_advantage_3": "In-place sorting",
  "selection_advantage_4": "Consistent performance (always O(n¬≤))",
  "selection_disadvantage_1": "Always O(n¬≤) even for sorted array",
  "selection_disadvantage_2": "Not stable",
  "selection_disadvantage_3": "Inefficient for large datasets",
  "selection_disadvantage_4": "Not adaptive (doesn't utilize sorted data)",
  "selection_visual_step_1": "üìä Array: [64, 25, 12, 22, 11]",
  "selection_visual_step_2": "üîç Find min: 11 ‚Üí Swap with 64",
  "selection_visual_step_3": "   [11, 25, 12, 22, 64]",
  "selection_visual_step_4": "üîç Find min: 12 ‚Üí Swap with 25",
  "selection_visual_step_5": "   [11, 12, 25, 22, 64]",
  "selection_visual_step_6": "üîç Find min: 22 ‚Üí Swap with 25",
  "selection_visual_step_7": "   [11, 12, 22, 25, 64]",
  "selection_visual_step_8": "‚úÖ Done!",
  "selection_quiz_1_question": "Question 1: Implement Selection Sort",
  "selection_quiz_1_hint": "Outer loop for position, inner loop finds min, then swap",
  "selection_use_cases": "‚Ä¢ When swap operation is costly\n‚Ä¢ Small arrays\n‚Ä¢ Learning algorithms\n‚Ä¢ Limited memory (in-place)",
  "selection_real_world": "Example: Selecting 5 shortest students in class\nScan all students, pick shortest, repeat",
  "heap_summary": "‚Ä¢ Uses Binary Heap data structure\n‚Ä¢ Builds max heap, then extracts max repeatedly\n‚Ä¢ In-place and O(n log n) for all cases\n‚Ä¢ Not stable but efficient",
  "heap_understanding": "Heap Sort uses Binary Heap data structure to sort array. It builds a max heap from the array, then repeatedly extracts the maximum element (root) and repairs the heap.",
  "heap_step_1": "1. Build max heap from array",
  "heap_step_2": "2. Swap root (max) with last element",
  "heap_step_3": "3. Reduce heap size",
  "heap_step_4": "4. Heapify root to fix heap",
  "heap_step_5": "5. Repeat steps 2-4 until heap is empty",
  "heap_time_complexity": "‚Ä¢ Best Case: O(n log n)\n‚Ä¢ Average Case: O(n log n)\n‚Ä¢ Worst Case: O(n log n) - CONSISTENT!",
  "heap_space_complexity": "‚Ä¢ O(1) - in-place sorting",
  "heap_advantage_1": "Consistent O(n log n) for all cases",
  "heap_advantage_2": "In-place sorting (O(1) space)",
  "heap_advantage_3": "No worst case O(n¬≤)",
  "heap_advantage_4": "Suitable for real-time systems",
  "heap_disadvantage_1": "Not stable",
  "heap_disadvantage_2": "Slower than Quick Sort in practice",
  "heap_disadvantage_3": "Cache-unfriendly (random access)",
  "heap_disadvantage_4": "Complex to understand",
  "heap_visual_step_1": "üìä Array: [12, 11, 13, 5, 6, 7]",
  "heap_visual_step_2": "üèóÔ∏è Build max heap: [13, 11, 12, 5, 6, 7]",
  "heap_visual_step_3": "üîÑ Swap 13 with 7: [7, 11, 12, 5, 6, 13]",
  "heap_visual_step_4": "üîß Heapify: [12, 11, 7, 5, 6, 13]",
  "heap_visual_step_5": "üîÑ Swap 12 with 6: [6, 11, 7, 5, 12, 13]",
  "heap_visual_step_6": "üîß Heapify: [11, 6, 7, 5, 12, 13]",
  "heap_visual_step_7": "üîÑ Process continues...",
  "heap_visual_step_8": "‚úÖ Result: [5, 6, 7, 11, 12, 13]",
  "heap_quiz_1_question": "Question 1: Implement heapify function",
  "heap_quiz_1_hint": "Find largest among i, left child, right child. Swap and recurse",
  "heap_use_cases": "‚Ä¢ Real-time systems (predictable performance)\n‚Ä¢ Embedded systems (O(1) space)\n‚Ä¢ Priority queue implementation\n‚Ä¢ When worst case O(n log n) is required",
  "heap_real_world": "Example: Task scheduling in OS\nHeap for priority queue, always pick highest priority task",
  "linear_summary": "‚Ä¢ Simplest search by checking every element\n‚Ä¢ Does not require sorted array\n‚Ä¢ Suitable for small arrays or one-time search\n‚Ä¢ Complexity O(n)",
  "linear_understanding": "Linear Search is the most basic search algorithm that checks every element in the array one by one until finding the target or reaching the end.",
  "linear_step_1": "1. Start from first element",
  "linear_step_2": "2. Compare current element with target",
  "linear_step_3": "3. If match, return index",
  "linear_step_4": "4. If not, continue to next element",
  "linear_step_5": "5. Repeat until found or end reached",
  "linear_step_6": "6. Return -1 if not found",
  "linear_time_complexity": "‚Ä¢ Best Case: O(1) - first element\n‚Ä¢ Average Case: O(n) - middle element\n‚Ä¢ Worst Case: O(n) - last element or not present",
  "linear_space_complexity": "‚Ä¢ O(1) - only needs index variable",
  "linear_advantage_1": "Very simple and easy to implement",
  "linear_advantage_2": "Does not require sorted array",
  "linear_advantage_3": "Suitable for small arrays",
  "linear_advantage_4": "Suitable for one-time search",
  "linear_advantage_5": "Works on all data types",
  "linear_disadvantage_1": "Slow for large arrays O(n)",
  "linear_disadvantage_2": "Inefficient for repeated searches",
  "linear_disadvantage_3": "Must check all elements in worst case",
  "linear_visual_step_1": "üìä Array: [64, 34, 25, 12, 22, 11, 90]",
  "linear_visual_step_2": "üéØ Target: 22",
  "linear_visual_step_3": "üëâ Index 0: 64 ‚â† 22",
  "linear_visual_step_4": "üëâ Index 1: 34 ‚â† 22",
  "linear_visual_step_5": "üëâ Index 2: 25 ‚â† 22",
  "linear_visual_step_6": "üëâ Index 3: 12 ‚â† 22",
  "linear_visual_step_7": "üëâ Index 4: 22 = 22 ‚úÖ",
  "linear_visual_step_8": "‚úÖ Found at index 4!",
  "linear_quiz_1_question": "Question 1: Implement Linear Search",
  "linear_quiz_1_hint": "Loop from 0 to length-1, compare each element with target",
  "linear_quiz_2_question": "Question 2: Modify to find all occurrences",
  "linear_quiz_2_hint": "Create empty list, add every matching index",
  "linear_quiz_3_question": "Question 3: Implement with sentinel (optimization)",
  "linear_quiz_3_hint": "Store last element, set it as target, loop without bound check",
  "linear_use_cases": "‚Ä¢ Small arrays (< 100 elements)\n‚Ä¢ Unsorted arrays\n‚Ä¢ One-time search\n‚Ä¢ Rarely searched data",
  "linear_real_world": "Example: Finding a name in list of 10 guests\nLinear search is fast enough for this size",
  "binary_summary": "‚Ä¢ Efficient search on sorted array\n‚Ä¢ Divides array in half each iteration\n‚Ä¢ Complexity O(log n) - very fast!\n‚Ä¢ Requires sorted array beforehand",
  "binary_understanding": "Binary Search is a highly efficient search algorithm for sorted arrays. It works by dividing the array into two halves and discarding the half that cannot contain the target.",
  "binary_step_1": "1. Set left = 0, right = n-1",
  "binary_step_2": "2. Calculate mid = (left + right) / 2",
  "binary_step_3": "3. If arr[mid] == target, return mid",
  "binary_step_4": "4. If arr[mid] < target, search right (left = mid + 1)",
  "binary_step_5": "5. If arr[mid] > target, search left (right = mid - 1)",
  "binary_step_6": "6. Repeat until found or left > right",
  "binary_time_complexity": "‚Ä¢ Best Case: O(1) - middle element\n‚Ä¢ Average Case: O(log n)\n‚Ä¢ Worst Case: O(log n) - very efficient!",
  "binary_space_complexity": "‚Ä¢ Iterative: O(1)\n‚Ä¢ Recursive: O(log n) - for call stack",
  "binary_advantage_1": "Very fast O(log n)",
  "binary_advantage_2": "Efficient for large arrays",
  "binary_advantage_3": "Suitable for repeated searches",
  "binary_advantage_4": "Can be implemented iteratively or recursively",
  "binary_disadvantage_1": "Requires sorted array",
  "binary_disadvantage_2": "Inefficient if frequent insert/delete",
  "binary_disadvantage_3": "Sorting overhead if array not sorted",
  "binary_visual_step_1": "üìä Sorted Array: [11, 12, 22, 25, 34, 64, 90]",
  "binary_visual_step_2": "üéØ Target: 25",
  "binary_visual_step_3": "üìç L=0, R=6, M=3: arr[3]=25",
  "binary_visual_step_4": "‚úÖ Found immediately!",
  "binary_visual_step_5": "",
  "binary_visual_step_6": "Another example - Target: 90",
  "binary_visual_step_7": "üìç L=0, R=6, M=3: arr[3]=25 < 90 ‚Üí Right",
  "binary_visual_step_8": "üìç L=4, R=6, M=5: arr[5]=64 < 90 ‚Üí Right",
  "binary_visual_step_9": "üìç L=6, R=6, M=6: arr[6]=90 ‚úÖ",
  "binary_quiz_1_question": "Question 1: Implement Iterative Binary Search",
  "binary_quiz_1_hint": "While left <= right, calculate mid, compare, update left/right",
  "binary_quiz_2_question": "Question 2: Implement Recursive Binary Search",
  "binary_quiz_2_hint": "Base case: left > right. Calculate mid, recurse left or right",
  "binary_quiz_3_question": "Question 3: Find first index of repeating element",
  "binary_quiz_3_hint": "When found, store result but keep searching left",
  "binary_use_cases": "‚Ä¢ Large sorted arrays\n‚Ä¢ Repeated searches\n‚Ä¢ Database indexing\n‚Ä¢ Dictionary/phonebook lookup",
  "binary_real_world": "Example: Finding word in 100,000 word dictionary\nLinear: ~50,000 comparisons\nBinary: ~17 comparisons (log‚ÇÇ 100,000)",
  "interpolation_summary": "‚Ä¢ Smarter version of Binary Search\n‚Ä¢ Guesses position based on target value\n‚Ä¢ Very efficient for uniformly distributed data\n‚Ä¢ Complexity O(log log n) for uniform data",
  "interpolation_understanding": "Interpolation Search is an improvement over Binary Search that guesses the position of the element based on its value, like how we find a word in a dictionary (jumping straight to the letter, not always middle).",
  "interpolation_step_1": "1. Calculate position with linear interpolation",
  "interpolation_step_2": "2. pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])",
  "interpolation_step_3": "3. If arr[pos] == target, return pos",
  "interpolation_step_4": "4. If arr[pos] < target, search right",
  "interpolation_step_5": "5. If arr[pos] > target, search left",
  "interpolation_step_6": "6. Repeat until found or range invalid",
  "interpolation_time_complexity": "‚Ä¢ Best Case: O(1)\n‚Ä¢ Average Case: O(log log n) - for uniform data\n‚Ä¢ Worst Case: O(n) - for non-uniform data",
  "interpolation_space_complexity": "‚Ä¢ O(1) - iterative",
  "interpolation_advantage_1": "Faster than Binary Search for uniform data",
  "interpolation_advantage_2": "O(log log n) is very efficient",
  "interpolation_advantage_3": "Suitable for uniformly distributed numeric data",
  "interpolation_disadvantage_1": "Requires sorted and uniform data",
  "interpolation_disadvantage_2": "Worst case O(n) for skewed data",
  "interpolation_disadvantage_3": "More complex than Binary Search",
  "interpolation_disadvantage_4": "Can overflow for large values",
  "interpolation_visual_step_1": "üìä Array: [10, 20, 30, 40, 50, 60, 70, 80, 90]",
  "interpolation_visual_step_2": "üéØ Target: 70",
  "interpolation_visual_step_3": "üßÆ Interpolation: pos = 0 + (70-10)*(8-0)/(90-10)",
  "interpolation_visual_step_4": "   pos = 0 + 60*8/80 = 0 + 6 = 6",
  "interpolation_visual_step_5": "üìç Check arr[6] = 70 ‚úÖ",
  "interpolation_visual_step_6": "‚úÖ Found immediately!",
  "interpolation_visual_step_7": "",
  "interpolation_visual_step_8": "Binary Search needs 2-3 iterations",
  "interpolation_visual_step_9": "Interpolation: 1 iteration!",
  "interpolation_quiz_1_question": "Question 1: Implement Interpolation Search",
  "interpolation_quiz_1_hint": "Calculate pos with interpolation formula, then like binary search",
  "interpolation_use_cases": "‚Ä¢ Uniformly distributed numeric data\n‚Ä¢ Databases with sequential keys\n‚Ä¢ Searching in large ranges with even data\n‚Ä¢ Phonebook with evenly distributed names",
  "interpolation_real_world": "Example: Finding page 750 in 1000 page book\nInterpolation: Open ~75% of book immediately\nBinary: Open middle (500), then 750, etc",
  "summary_title": "Your Summary",
  "summary_this_week": "This Week",
  "summary_completed": "COMPLETED",
  "summary_total_progress": "Total Progress",
  "summary_total_xp": "TOTAL XP",
  "summary_streak": "STREAK",
  "summary_xp_today": "XP today",
  "summary_today": "today",
  "last_learned_title": "Last Learned",
  "last_learned_time_ago": "hours ago",
  "catalog_title": "Visualization Catalog",
  "view_all": "View All",
  "no_learning_yet": "Start learning to see your progress!",
  "profile_title": "Profile",
  "profile_level": "Level",
  "profile_master": "Algorithm Master",
  "profile_progress_summary": "PROGRESS SUMMARY",
  "profile_detail": "Detail >",
  "profile_algorithms": "Algorithms",
  "profile_total_xp": "Total XP",
  "profile_streak": "Streak",
  "profile_achievements": "Achievements & Badges",
  "profile_achievements_subtitle": "View all your achievements",
  "profile_account_settings": "ACCOUNT SETTINGS",
  "profile_edit": "Edit Profile",
  "profile_edit_subtitle": "Change photo & basic info",
  "profile_security": "Security",
  "profile_security_subtitle": "Password & 2FA",
  "profile_notifications": "Notifications",
  "profile_notifications_subtitle": "Set preferences",
  "profile_language": "Language",
  "profile_language_subtitle": "English (EN)",
  "profile_logout": "Logout",
  "profile_version": "Version",
  "achievements_title": "Achievements & Badges",
  "level": "LEVEL",
  "master_algorithm": "Master Algorithm",
  "badge_collection": "Badge Collection",
  "unlocked": "Unlocked",
  "latest_achievements": "Latest Achievements",
  "badge_algo_novice": "Algo Novice",
  "badge_algo_novice_desc": "Reach 100 XP",
  "badge_algo_master": "Algo Master",
  "badge_algo_master_desc": "Complete 50 algorithms",
  "badge_speed_demon": "Speed Demon",
  "badge_speed_demon_desc": "Solve in under 30 sec",
  "badge_elite_pro": "Elite Pro",
  "badge_elite_pro_desc": "Reach level 10",
  "badge_mentor": "Mentor",
  "badge_mentor_desc": "Help 5 learners",
  "achievement_sorting_10": "Solved 10 Sorting Algo",
  "achievement_sorting_10_desc": "Complete 10 sorting algorithms",
  "achievement_first_algo": "First Step",
  "achievement_first_algo_desc": "Solve your first algorithm",
  "achievement_sorting_master": "Sorting Master",
  "achievement_sorting_master_desc": "Solve 5 sorting algorithms",
  "achievement_streak_hero": "Streak Hero",
  "achievement_streak_hero_desc": "Reach a 7-day streak",
  "achievement_dedicated_learner": "Dedicated Learner",
  "achievement_dedicated_learner_desc": "Complete 10 learning sessions",
  "achievement_streak_30": "Streak 30 Days",
  "achievement_streak_30_desc": "Maintain 30-day streak",
  "achievement_master_return": "Master Return",
  "achievement_master_return_desc": "Complete 5 advanced modules",
  "no_learning_subtitle": "Begin your journey to master algorithms",
  "start_learning_now": "Start Learning Now",
  "bottom_sheet_title_1": "Choose Visualization",
  "bottom_sheet_title_2": "Algorithm",
  "bottom_sheet_search": "Search Algorithm...",
  "bottom_sheet_start": "Start Visualization",
  "bottom_sheet_detail": "View Full Details",
  "menu_home": "Home",
  "menu_learn": "Learn",
  "menu_profile": "Profile",
  "module_locked": "LOCKED",
  "module_completed": "COMPLETED",
  "quiz_correct_msg": "‚úÖ Correct! Your code is correct.",
  "quiz_incorrect_msg": "‚ùå Not quite right. Try again!",
  "quiz_expected_msg": "Expected:",
  "quiz_hint": "Hint:",
  "quiz_default_explanation": "Your implementation matches the expected solution!",
  "error_content_not_found": "Content for algorithm {algorithmId} not found",
  "quiz_explanation": "Explanation:",
  "interactive_code": "Interactive Code",
  "case_study": "Case Study",
  "lab_bubble_title": "Bubble Up System",
  "lab_bubble_desc": "Simulating system load 'rising' to the surface based on priority. Heavier objects (large values) will sink to the bottom.",
  "lab_selection_title": "Warehouse Logistics",
  "lab_selection_desc": "Selecting the most efficient items from shelves to be moved to the main shipping line one by one.",
  "lab_insertion_title": "Dynamic Inventory",
  "lab_insertion_desc": "Inserting new data into an already sorted catalog, like arranging report cards or store inventory.",
  "lab_quick_title": "Big Data Sharding",
  "lab_quick_desc": "Dividing giant datasets into small partitions (shards) using Pivot Points for parallel processing.",
  "lab_simulation_done": "Simulation Finished",
  "lab_result_msg": "Data successfully optimized with {swaps} swaps and {comparisons} comparisons.",
  "lab_active_visualization": "ACTIVE VISUALIZATION",
  "lab_pathfinding_title": "Pathfinding Lab",
  "lab_case_study_logistics_title": "CASE STUDY: LOGISTICS OPTIMIZATION",
  "lab_case_study_logistics_body": "Finding the most efficient route for autonomous delivery drones in a smart city grid avoiding obstacles.",
  "lab_start_logistics": "START LOGISTICS",
  "lab_reset_grid": "RESET GRID",
  "lab_clear_obstacles": "CLEAR ALL OBSTACLES",
  "lab_case_study": "CASE STUDY",
  "lab_run": "Run",
  "lab_shuffle": "Reshuffle",
  "lab_speed": "Simulation Speed",
  "lab_searching_min": "Searching for Minimum...",
  "lab_pivot": "PIVOT",
  "global_rank_top_1": "Top 1% Global",
  "global_rank_top_5": "Top 5% Global",
  "global_rank_top_10": "Top 10% Global",
  "global_rank_top_25": "Top 25% Global",
  "time_days_ago": "days ago",
  "time_hours_ago": "hours ago",
  "time_minutes_ago": "mins ago",
  "time_just_now": "just now",
  "time_recently": "recently",
  "badge_unlocked_title": "NEW BADGE UNLOCKED!",
  "collect_now": "Collect Now",
  "notification_badge_unlocked_title": "Badge Unlocked!",
  "notification_badge_unlocked_body": "Congratulations! You've unlocked the {name} badge.",
  "notification_achievement_reached_title": "Achievement Reached!",
  "notification_achievement_reached_body": "Well done! You've completed: {name}",
  "bfs_summary": "‚Ä¢ Level-by-level graph traversal using queue\n‚Ä¢ Visits all neighbors before going to next level\n‚Ä¢ Finds shortest path in unweighted graphs\n‚Ä¢ Complexity O(V + E)",
  "bfs_understanding": "BFS (Breadth-First Search) is a graph traversal algorithm that visits nodes level by level. Starting from a source node, it visits all its neighbors, then neighbors of neighbors, and so on. It uses a queue (FIFO).",
  "bfs_step_1": "1. Start from source node, add to queue",
  "bfs_step_2": "2. Mark node as visited",
  "bfs_step_3": "3. Dequeue node, visit it",
  "bfs_step_4": "4. Enqueue all unvisited neighbors",
  "bfs_step_5": "5. Mark neighbors as visited",
  "bfs_step_6": "6. Repeat until queue is empty",
  "bfs_time_complexity": "‚Ä¢ O(V + E) where V = vertices, E = edges\n‚Ä¢ Each vertex and edge is visited once",
  "bfs_space_complexity": "‚Ä¢ O(V) - for queue and visited set",
  "bfs_advantage_1": "Finds shortest path in unweighted graphs",
  "bfs_advantage_2": "Level-order traversal",
  "bfs_advantage_3": "Suitable for graphs that are not too deep",
  "bfs_advantage_4": "Can find all connected components",
  "bfs_disadvantage_1": "Requires more memory for wide graphs",
  "bfs_disadvantage_2": "Not optimal for very deep graphs",
  "bfs_disadvantage_3": "Cannot handle weighted graphs for shortest path",
  "bfs_visual_step_1": "üìä Graph Structure:",
  "bfs_visual_step_2": "0 as root, connected to 1 and 2.",
  "bfs_visual_step_3": "üîÑ BFS from 0:",
  "bfs_visual_step_4": "Level 0: [0] | Level 1: [1, 2] | Level 2: [3, 4]",
  "bfs_visual_step_5": "‚úÖ Visit Order: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4",
  "bfs_quiz_1_question": "Problem 1: Implement BFS",
  "bfs_quiz_1_hint": "Use a Queue and a Visited Set. Dequeue a node, visit it, then enqueue its neighbors.",
  "bfs_use_cases": "‚Ä¢ Shortest path in unweighted graphs\n‚Ä¢ Social networks (friends of friends)\n‚Ä¢ Web crawlers\n‚Ä¢ GPS navigation (unweighted)",
  "bfs_real_world": "Example: Facebook \"People You May Know\"\nBFS level 2-3 from your profile for friend recommendations.",
  "dfs_summary": "‚Ä¢ Depth-first graph traversal using stack/recursion\n‚Ä¢ Explores as deep as possible before backtracking\n‚Ä¢ Suitable for cycle detection and topological sort\n‚Ä¢ Complexity O(V + E)",
  "dfs_understanding": "DFS (Depth-First Search) is a graph traversal algorithm that explores as deep as possible along each branch before backtracking. It uses a stack (or implicit call stack with recursion).",
  "dfs_step_1": "1. Start from source node",
  "dfs_step_2": "2. Mark node as visited",
  "dfs_step_3": "3. Visit the node",
  "dfs_step_4": "4. For each unvisited neighbor:",
  "dfs_step_5": "5. Recursively perform DFS on neighbor",
  "dfs_step_6": "6. Backtrack if all neighbors are visited",
  "dfs_time_complexity": "‚Ä¢ O(V + E) where V = vertices, E = edges",
  "dfs_space_complexity": "‚Ä¢ O(V) - for recursion stack and visited set",
  "dfs_advantage_1": "More memory efficient for deep graphs",
  "dfs_advantage_2": "Suitable for cycle detection",
  "dfs_advantage_3": "Topological sorting",
  "dfs_advantage_4": "Pathfinding with backtracking",
  "dfs_disadvantage_1": "Can get stuck in deep branches without a solution",
  "dfs_disadvantage_2": "Does not guarantee shortest path",
  "dfs_disadvantage_3": "Stack overflow for very deep graphs",
  "dfs_visual_step_1": "üìä Same Graph Structure",
  "dfs_visual_step_2": "üîÑ DFS from 0:",
  "dfs_visual_step_3": "0 ‚Üí 1 ‚Üí 3 (backtrack)",
  "dfs_visual_step_4": "1 ‚Üí 4 (backtrack) | 0 ‚Üí 2 (backtrack)",
  "dfs_visual_step_5": "‚úÖ Visit Order: 0 ‚Üí 1 ‚Üí 3 ‚Üí 4 ‚Üí 2",
  "dfs_quiz_1_question": "Problem 1: Implement recursive DFS",
  "dfs_quiz_1_hint": "Mark as visited, print, recurse to all unvisited neighbors.",
  "dfs_use_cases": "‚Ä¢ Detecting cycles in a graph\n‚Ä¢ Topological sorting\n‚Ä¢ Maze solving\n‚Ä¢ Puzzle solving (Sudoku, N-Queens)",
  "dfs_real_world": "Example: Solving a maze\nDFS explores one path as deep as possible, backtracks if stuck.",
  "dijkstra_summary": "‚Ä¢ Shortest path algorithm for weighted graphs\n‚Ä¢ Uses greedy approach with priority queue\n‚Ä¢ Cannot handle negative weights\n‚Ä¢ Complexity O((V + E) log V) with min-heap",
  "dijkstra_understanding": "Dijkstra's algorithm finds the shortest path from a starting node to all other nodes in a weighted graph. It uses a greedy approach: always pick the node with the shortest distance that hasn't been visited yet.",
  "dijkstra_step_1": "1. Set all distances to infinity, start = 0",
  "dijkstra_step_2": "2. Add start node to Priority Queue",
  "dijkstra_step_3": "3. Pick node with min distance from queue",
  "dijkstra_step_4": "4. Relax neighbors: if new path is shorter, update dist",
  "dijkstra_step_5": "5. Repeat until queue is empty",
  "dijkstra_time_complexity": "‚Ä¢ O((V + E) log V) with binary heap\n‚Ä¢ O(V¬≤) with simple array\n‚Ä¢ O(V + E) with Fibonacci heap",
  "dijkstra_space_complexity": "‚Ä¢ O(V) - for distances and priority queue",
  "dijkstra_advantage_1": "Finds optimal shortest path",
  "dijkstra_advantage_2": "Efficient for sparse graphs",
  "dijkstra_advantage_3": "Can be optimized with various heaps",
  "dijkstra_advantage_4": "Widely used and well-tested",
  "dijkstra_disadvantage_1": "Cannot handle negative edge weights",
  "dijkstra_disadvantage_2": "Slower than BFS for unweighted graphs",
  "dijkstra_disadvantage_3": "Requires an efficient priority queue",
  "dijkstra_visual_step_1": "üìä Weighted Graph:",
  "dijkstra_visual_step_2": "Init: [0:0, 1:‚àû, 2:‚àû, 3:‚àû]",
  "dijkstra_visual_step_3": "Visit 0: [0:0, 1:4, 2:1, 3:‚àû]",
  "dijkstra_visual_step_4": "Visit 2: [0:0, 1:4, 2:1, 3:3]",
  "dijkstra_visual_step_5": "‚úÖ Shortest paths found!",
  "dijkstra_quiz_1_question": "Problem 1: Implement simple Dijkstra",
  "dijkstra_quiz_1_hint": "Init distances, loop V times, pick min unvisited node, relax its edges.",
  "dijkstra_use_cases": "‚Ä¢ GPS navigation (Google Maps)\n‚Ä¢ Network routing protocols\n‚Ä¢ Social network analysis\n‚Ä¢ Game AI pathfinding",
  "dijkstra_real_world": "Example: Google Maps finding the fastest route\nDijkstra with traffic data as weights.",
  "bellman_summary": "‚Ä¢ Shortest path algorithm that handles negative weights\n‚Ä¢ Slower than Dijkstra but more versatile\n‚Ä¢ Can detect negative cycles\n‚Ä¢ Complexity O(VE)",
  "bellman_understanding": "Bellman-Ford is a shortest path algorithm that can handle edges with negative weights. It works by relaxing all edges V-1 times to guarantee the shortest path is found.",
  "bellman_step_1": "1. Initialize distances to infinity, start = 0",
  "bellman_step_2": "2. Relax all edges V-1 times",
  "bellman_step_3": "3. Check for negative cycles with one more pass",
  "bellman_step_4": "4. If distance updates, negative cycle exists",
  "bellman_time_complexity": "‚Ä¢ O(VE) - V-1 iterations, each checks all E edges\n‚Ä¢ Slower than Dijkstra's O((V+E) log V)",
  "bellman_space_complexity": "‚Ä¢ O(V) - for distances array",
  "bellman_advantage_1": "Handles negative weight edges",
  "bellman_advantage_2": "Detects negative cycles",
  "bellman_advantage_3": "Simpler than Dijkstra",
  "bellman_advantage_4": "Suitable for distributed systems",
  "bellman_disadvantage_1": "Slower complexity O(VE)",
  "bellman_disadvantage_2": "Inefficient for very large graphs",
  "bellman_disadvantage_3": "Cannot handle negative cycles for shortest path",
  "bellman_visual_step_1": "üìç Iteration 1: Relax all 10 edges",
  "bellman_visual_step_2": "üìç Iteration 2: Relax again, distances updated",
  "bellman_visual_step_3": "üìç Iteration 3: No more updates",
  "bellman_visual_step_4": "‚úÖ Done: No negative cycle",
  "bellman_quiz_1_question": "Problem 1: Implement Bellman-Ford",
  "bellman_quiz_1_hint": "Init distances, loop V-1 times, relax all edges.",
  "bellman_use_cases": "‚Ä¢ Network routing with negative costs\n‚Ä¢ Currency arbitrage detection\n‚Ä¢ Distributed systems\n‚Ä¢ Situations with negative weights",
  "bellman_real_world": "Example: Currency arbitrage detection\nNegative cycle = profit opportunity from currency exchange.",
  "floyd_summary": "‚Ä¢ Finds shortest paths between all pairs of nodes\n‚Ä¢ Dynamic programming algorithm\n‚Ä¢ Works with negative weights (no negative cycles)\n‚Ä¢ Complexity O(V¬≥)",
  "floyd_understanding": "Floyd-Warshall algorithm finds the shortest distance between every pair of vertices in a weighted graph. It works by considering each node as an intermediate point between all other pairs.",
  "floyd_step_1": "1. Initialize distance matrix with edge weights",
  "floyd_step_2": "2. For each intermediate node k:",
  "floyd_step_3": "3. For each pair (i, j):",
  "floyd_step_4": "4. Update dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])",
  "floyd_time_complexity": "‚Ä¢ O(V¬≥) - triple nested loop\n‚Ä¢ Suitable for dense graphs with small V",
  "floyd_space_complexity": "‚Ä¢ O(V¬≤) - for distances matrix",
  "floyd_advantage_1": "Finds ALL-pairs shortest paths at once",
  "floyd_advantage_2": "Simple implementation",
  "floyd_advantage_3": "Handles negative weight edges",
  "floyd_advantage_4": "Suitable for dense graphs",
  "floyd_disadvantage_1": "Very slow O(V¬≥)",
  "floyd_disadvantage_2": "Requires O(V¬≤) memory",
  "floyd_disadvantage_3": "Inefficient for sparse graphs",
  "floyd_disadvantage_4": "Not suitable for large graphs",
  "floyd_visual_step_1": "üìä Graph with 4 nodes",
  "floyd_visual_step_2": "k=0: Update paths via node 0",
  "floyd_visual_step_3": "k=1: Update paths via node 1",
  "floyd_visual_step_4": "k=2: Update paths via node 2",
  "floyd_visual_step_5": "‚úÖ All shortest paths found!",
  "floyd_quiz_1_question": "Problem 1: Implement Floyd-Warshall",
  "floyd_quiz_1_hint": "Triple nested loop: k (intermediate), i (from), j (to).",
  "floyd_use_cases": "‚Ä¢ Network routing tables\n‚Ä¢ Finding transitive closure\n‚Ä¢ Detecting negative cycles\n‚Ä¢ Small dense graphs",
  "floyd_real_world": "Example: Routing table in a router\nCalculate shortest path to all destinations.",
  "kruskal_summary": "‚Ä¢ Finds Minimum Spanning Tree (MST) of a graph\n‚Ä¢ Uses greedy approach by sorting all edges\n‚Ä¢ Uses Union-Find data structure to prevent cycles\n‚Ä¢ Complexity O(E log E) or O(E log V)",
  "kruskal_understanding": "Kruskal's algorithm finds the Minimum Spanning Tree of a connected, undirected graph. It sorts all edges by weight and adds the smallest edges that don't form a cycle.",
  "kruskal_step_1": "1. Sort all edges from low weight to high",
  "kruskal_step_2": "2. Pick the smallest edge",
  "kruskal_step_3": "3. If it doesn't form a cycle, add to MST",
  "kruskal_step_4": "4. Repeat until V-1 edges are added",
  "kruskal_time_complexity": "‚Ä¢ O(E log E) - dominated by sorting\n‚Ä¢ Uses optimal Union-Find",
  "kruskal_space_complexity": "‚Ä¢ O(V + E) - for Union-Find and edge list",
  "kruskal_advantage_1": "Efficient for sparse graphs",
  "kruskal_advantage_2": "Simple and easy to implement",
  "kruskal_advantage_3": "Suitable for edge-based representation",
  "kruskal_advantage_4": "Optimal greedy approach",
  "kruskal_disadvantage_1": "Requires sorting O(E log E)",
  "kruskal_disadvantage_2": "Inefficient for dense graphs",
  "kruskal_disadvantage_3": "Needs Union-Find structure",
  "kruskal_visual_step_1": "üìä Graph with weights",
  "kruskal_visual_step_2": "1. Sort edges: [1-2:1, 1-3:2, 0-2:3, 0-1:4, 2-3:4]",
  "kruskal_visual_step_3": "2. Add 1-2 (weight 1) ‚úì | 3. Add 1-3 (weight 2) ‚úì",
  "kruskal_visual_step_4": "4. Add 0-2 (weight 3) ‚úì | 5. Skip 0-1 (cycle)",
  "kruskal_visual_step_5": "‚úÖ MST weight: 6",
  "kruskal_quiz_1_question": "Problem 1: Implement Kruskal",
  "kruskal_quiz_1_hint": "Sort edges, use Union-Find to check for cycles.",
  "kruskal_use_cases": "‚Ä¢ Network design (minimize cable cost)\n‚Ä¢ Clustering algorithms\n‚Ä¢ Image segmentation\n‚Ä¢ Approximation algorithms",
  "kruskal_real_world": "Example: Fiber optic cable network design\nConnect all cities with minimum cost.",
  "prim_summary": "‚Ä¢ Finds Minimum Spanning Tree (MST) from a start node\n‚Ä¢ Uses greedy approach with priority queue (min-heap)\n‚Ä¢ Suitable for dense graphs\n‚Ä¢ Complexity O(E log V)",
  "prim_understanding": "Prim's algorithm finds the MST of a graph by starting from a node and always adding the cheapest edge that connects a visited node to an unvisited node.",
  "prim_step_1": "1. Choose starting node",
  "prim_step_2": "2. Add all connecting edges to Priority Queue",
  "prim_step_3": "3. Pick edge with min weight to an unvisited node",
  "prim_step_4": "4. Mark node visited",
  "prim_step_5": "5. Search for next min weight edge",
  "prim_step_6": "6. Repeat until all nodes connected",
  "prim_time_complexity": "‚Ä¢ O(E log V) with binary heap\n‚Ä¢ O(E + V log V) with Fibonacci heap",
  "prim_space_complexity": "‚Ä¢ O(V + E) - for graph and priority queue",
  "prim_advantage_1": "Efficient for dense graphs",
  "prim_advantage_2": "Suitable for adjacency list representation",
  "prim_advantage_3": "Can be optimized with Fibonacci heap",
  "prim_advantage_4": "More intuitive than Kruskal",
  "prim_disadvantage_1": "Requires complex priority queue",
  "prim_disadvantage_2": "More complex than Kruskal",
  "prim_disadvantage_3": "Inefficient for sparse graphs",
  "prim_visual_step_1": "üìä Same Graph structure",
  "prim_visual_step_2": "1. Start: visited={0}",
  "prim_visual_step_3": "2. Add 0-2 (weight 3), visited={0,2}",
  "prim_visual_step_4": "3. Add 2-1 (weight 1), visited={0,2,1}",
  "prim_visual_step_5": "‚úÖ MST weight: 6",
  "prim_quiz_1_question": "Problem 1: Implement simple Prim",
  "prim_quiz_1_hint": "Use priority queue, visited set, add minimum weight edges.",
  "prim_use_cases": "‚Ä¢ Network design\n‚Ä¢ Clustering\n‚Ä¢ Approximation algorithms\n‚Ä¢ Dense graphs",
  "prim_real_world": "Example: Power grid design\nConnect all houses with minimum cabling.",
  "caesar_summary": "‚Ä¢ Simplest substitution cipher\n‚Ä¢ Shifts each letter by n positions\n‚Ä¢ Easily broken by brute force\n‚Ä¢ Complexity O(n) for encrypt/decrypt",
  "caesar_understanding": "Caesar Cipher is a classic encryption technique that shifts each letter in the plaintext by a certain number of positions in the alphabet. For example with shift 3, 'A' becomes 'D', 'B' becomes 'E', etc.",
  "caesar_step_1": "1. Determine shift value (key)",
  "caesar_step_2": "2. For each character: if letter, shift it",
  "caesar_step_3": "3. Wrap around if path Z (A becomes D with shift 3)",
  "caesar_step_4": "4. For decryption, shift in reverse",
  "caesar_time_complexity": "‚Ä¢ O(n) where n = length of text\n‚Ä¢ Each character processed once",
  "caesar_space_complexity": "‚Ä¢ O(n) - for result string",
  "caesar_advantage_1": "Very simple and easy to understand",
  "caesar_advantage_2": "Fast for encryption/decryption",
  "caesar_advantage_3": "No complex computation needed",
  "caesar_advantage_4": "Good for learning cryptography",
  "caesar_disadvantage_1": "Very insecure (only 26 possible keys)",
  "caesar_disadvantage_2": "Easy to break with brute force",
  "caesar_disadvantage_3": "Vulnerable to frequency analysis",
  "caesar_disadvantage_4": "Not suitable for sensitive data",
  "caesar_visual_step_1": "üìù Plaintext: HELLO",
  "caesar_visual_step_2": "üîë Shift: 3",
  "caesar_visual_step_3": "üîÑ Encryption:",
  "caesar_visual_step_4": "H (7) + 3 = K (10) | E (4) + 3 = H (7)",
  "caesar_visual_step_5": "L (11) + 3 = O (14) | L (11) + 3 = O (14)",
  "caesar_visual_step_6": "O (14) + 3 = R (17)",
  "caesar_visual_step_7": "üîí Ciphertext: KHOOR",
  "caesar_quiz_1_question": "Problem 1: Implement Caesar encryption",
  "caesar_quiz_1_hint": "Loop each char, check letter, shift with modulo 26.",
  "caesar_quiz_2_question": "Problem 2: Implement decryption",
  "caesar_quiz_2_hint": "Decryption = encryption with shift (26 - shift).",
  "caesar_use_cases": "‚Ä¢ Basic cryptography learning\n‚Ä¢ ROT13 (shift 13) for obfuscation\n‚Ä¢ Puzzles and games\n‚Ä¢ Concept demonstration",
  "caesar_real_world": "Example: ROT13 on internet forums\nHiding spoilers or puzzle answers.",
  "vigenere_summary": "‚Ä¢ Polyalphabetic substitution cipher\n‚Ä¢ Uses keyword for multiple shifts\n‚Ä¢ More secure than Caesar Cipher\n‚Ä¢ Complexity O(n)",
  "vigenere_understanding": "Vigenere Cipher is an extension of the Caesar Cipher that uses a keyword to determine different shifts for each letter. This makes it harder to break with frequency analysis.",
  "vigenere_step_1": "1. Determine keyword",
  "vigenere_step_2": "2. Repeat keyword to match plaintext length",
  "vigenere_step_3": "3. For each letter: get shift from key letter position",
  "vigenere_step_4": "4. Apply Caesar shift with that value",
  "vigenere_step_5": "5. For decryption, subtract the shift",
  "vigenere_step_6": "6. Resulting string is ciphertext",
  "vigenere_time_complexity": "‚Ä¢ O(n) where n = text length",
  "vigenere_space_complexity": "‚Ä¢ O(n) - for result string",
  "vigenere_advantage_1": "More secure than Caesar Cipher",
  "vigenere_advantage_2": "Resistant to simple frequency analysis",
  "vigenere_advantage_3": "Easy to implement",
  "vigenere_advantage_4": "Keyword can be of arbitrary length",
  "vigenere_disadvantage_1": "Can be broken with Kasiski examination",
  "vigenere_disadvantage_2": "Vulnerable if keyword is short",
  "vigenere_disadvantage_3": "Not secure for modern standards",
  "vigenere_disadvantage_4": "Requires key management",
  "vigenere_visual_step_1": "üìù Plaintext: HELLO",
  "vigenere_visual_step_2": "üîë Key: KEY (K=10, E=4, Y=24)",
  "vigenere_visual_step_3": "üîÑ Encryption:",
  "vigenere_visual_step_4": "H+K=R, E+E=I, L+Y=J, L+K=V, O+E=S",
  "vigenere_visual_step_5": "üîí Ciphertext: RIJVS",
  "vigenere_visual_step_6": "‚úÖ Done!",
  "vigenere_quiz_1_question": "Problem 1: Implement Vigenere encryption",
  "vigenere_quiz_1_hint": "Loop text, get shift from key with modulo, encrypt.",
  "vigenere_use_cases": "‚Ä¢ Cryptography education\n‚Ä¢ Simple encryption for non-critical data\n‚Ä¢ Polyalphabetic cipher demo\n‚Ä¢ Historical study",
  "vigenere_real_world": "Example: Used by Confederacy in American Civil War\nFor encrypting military messages.",
  "rsa_summary": "‚Ä¢ Public-key cryptography algorithm\n‚Ä¢ Uses two keys: public and private\n‚Ä¢ Based on modular math and large primes\n‚Ä¢ Complexity: Encrypt/Decrypt takes O(log n)",
  "rsa_understanding": "RSA is an asymmetric cryptographic algorithm that uses a pair of keys: a public key for encryption and a private key for decryption. Its security relies on the difficulty of factoring large numbers.",
  "rsa_step_1": "1. Choose two large primes p and q",
  "rsa_step_2": "2. Compute n = p * q",
  "rsa_step_3": "3. Compute phi = (p-1) * (q-1)",
  "rsa_step_4": "4. Choose e such that 1 < e < phi and coprime with phi",
  "rsa_step_5": "5. Compute d (inverse of e mod phi)",
  "rsa_step_6": "6. Public Key: (e, n), Private Key: (d, n)",
  "rsa_step_7": "7. Encrypt: c = m^e mod n",
  "rsa_step_8": "8. Decrypt: m = c^d mod n",
  "rsa_time_complexity": "‚Ä¢ Key gen: O(k¬≥), Encrypt/Decrypt: O(log n)",
  "rsa_space_complexity": "‚Ä¢ O(k) to store keys",
  "rsa_advantage_1": "Public-key (no secret key sharing needed)",
  "rsa_advantage_2": "Can be used for digital signatures",
  "rsa_advantage_3": "Widely used and well-tested",
  "rsa_advantage_4": "Security based on hard math problems",
  "rsa_disadvantage_1": "Slower than symmetric encryption",
  "rsa_disadvantage_2": "Requires large key size (2048+ bits)",
  "rsa_disadvantage_3": "Vulnerable to quantum computing",
  "rsa_disadvantage_4": "Complex to implement correctly",
  "rsa_visual_step_1": "üîë Key Gen: p=61, q=53 ‚Üí n=3233, œÜ=3120",
  "rsa_visual_step_2": "üîë e=17, d=2753",
  "rsa_visual_step_3": "üîí Encrypt m=123:",
  "rsa_visual_step_4": "c = 123^17 mod 3233 = 855",
  "rsa_visual_step_5": "üîì Decrypt c=855:",
  "rsa_visual_step_6": "m = 855^2753 mod 3233 = 123",
  "rsa_quiz_1_question": "Problem 1: Implement modular exponentiation",
  "rsa_quiz_1_hint": "Use square-and-multiply method with modulo.",
  "rsa_use_cases": "‚Ä¢ HTTPS/SSL/TLS\n‚Ä¢ Digital signatures\n‚Ä¢ Secure email (PGP)\n‚Ä¢ Cryptocurrency",
  "rsa_real_world": "Example: HTTPS in browser\nRSA for key exchange, then symmetric for data.",
  "aes_summary": "‚Ä¢ Advanced Encryption Standard\n‚Ä¢ Symmetric block cipher\n‚Ä¢ Uses substitution-permutation network\n‚Ä¢ Key sizes: 128, 192, or 256 bits",
  "aes_understanding": "AES is a modern symmetric encryption standard that is highly secure and efficient. It uses repeated substitution and permutation operations on 128-bit data blocks.",
  "aes_step_1": "1. Key Expansion: Derive round keys",
  "aes_step_2": "2. Initial Round: AddRoundKey",
  "aes_step_3": "3. Main Rounds: SubBytes, ShiftRows, MixColumns, AddRoundKey",
  "aes_step_4": "4. Final Round: SubBytes, ShiftRows, AddRoundKey",
  "aes_time_complexity": "‚Ä¢ O(1) for block encryption/decryption\n‚Ä¢ Fixed number of rounds",
  "aes_space_complexity": "‚Ä¢ O(1) - in-place operations",
  "aes_advantage_1": "Extremely secure (US Gov standard)",
  "aes_advantage_2": "Fast and efficient",
  "aes_advantage_3": "Hardware acceleration available",
  "aes_advantage_4": "Widely supported globally",
  "aes_disadvantage_1": "Symmetric (requires secret key sharing)",
  "aes_disadvantage_2": "Complex to implement manually",
  "aes_disadvantage_3": "Block cipher (requires operation mode)",
  "aes_disadvantage_4": "Vulnerable to side-channel if not careful",
  "aes_visual_step_1": "üìä AES-128 Encryption Process:",
  "aes_visual_step_2": "üîë Input: 128-bit block & key",
  "aes_visual_step_3": "üîÑ Round 1-10 Operations",
  "aes_visual_step_4": "1. SubBytes (S-box)",
  "aes_visual_step_5": "2. ShiftRows | 3. MixColumns | 4. AddRoundKey",
  "aes_visual_step_6": "üîí Output: 128-bit ciphertext",
  "aes_quiz_1_question": "Problem 1: Implement AddRoundKey (XOR)",
  "aes_quiz_1_hint": "Loop and XOR each state byte with round key.",
  "aes_use_cases": "‚Ä¢ File encryption\n‚Ä¢ Disk encryption (BitLocker)\n‚Ä¢ VPN (IPsec, WireGuard)\n‚Ä¢ Wireless security (WPA3)",
  "aes_real_world": "Example: WhatsApp end-to-end encryption\nUses AES-256 for message encryption.",
  "sha256_summary": "‚Ä¢ One-way cryptographic hash function\n‚Ä¢ Produces fixed 256-bit (32-byte) output\n‚Ä¢ Low collision probability\n‚Ä¢ Used for data integrity and blockchain",
  "sha256_understanding": "SHA-256 (Secure Hash Algorithm 256-bit) is a hashing algorithm that takes an input of any size and produces a fixed-size 256-bit string. It is deterministic and one-way.",
  "sha256_step_1": "1. Padding: pad input up to 448 (mod 512)",
  "sha256_step_2": "2. Append length: add original message length",
  "sha256_step_3": "3. Initialize: 8 hash constants",
  "sha256_step_4": "4. Process: 64 rounds compression function",
  "sha256_step_5": "5. Finalize: concatenate hash values",
  "sha256_time_complexity": "‚Ä¢ O(n) where n = message length",
  "sha256_space_complexity": "‚Ä¢ O(1) - constant space needed",
  "sha256_advantage_1": "Highly secure and collision resistant",
  "sha256_advantage_2": "Deterministic and efficient",
  "sha256_advantage_3": "One-way property",
  "sha256_advantage_4": "No keys needed",
  "sha256_advantage_5": "Global standard",
  "sha256_disadvantage_1": "Vulnerable to length extension attacks",
  "sha256_disadvantage_2": "Rainbow table vulnerability if not salted",
  "sha256_disadvantage_3": "Not encryption (cannot be reversed)",
  "sha256_visual_step_1": "üìù Input: \"hello\"",
  "sha256_visual_step_2": "üîÑ Block Process (512-bit)",
  "sha256_visual_step_3": "üîÑ 64 Rounds Compression",
  "sha256_visual_step_4": "üîí Hash: 2cf24dba...938b9824",
  "sha256_quiz_1_question": "Problem 1: Implement right rotate (ROTR)",
  "sha256_quiz_1_hint": "Implement 32-bit right rotate using bitwise shifts and OR.",
  "sha256_use_cases": "‚Ä¢ Digital signatures\n‚Ä¢ Blockchain (Bitcoin)\n‚Ä¢ Password hashing (with salt)\n‚Ä¢ File integrity verification",
  "sha256_real_world": "Example: Bitcoin mining\nSHA-256 used to hash block headers."
}